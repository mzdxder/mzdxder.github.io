<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mazd &#39; s blog</title>
  
  <subtitle>Good Good Study, Day Day Up!</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-04-21T03:58:19.703Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Mazd</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机网络</title>
    <link href="http://example.com/2024/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>http://example.com/2024/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</id>
    <published>2024-04-21T03:56:05.000Z</published>
    <updated>2024-04-21T03:58:19.703Z</updated>
    
    
    
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="http://example.com/2024/04/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>http://example.com/2024/04/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</id>
    <published>2024-04-21T03:55:56.000Z</published>
    <updated>2024-04-21T07:04:56.747Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、进程和线程的区别？"><a href="#一、进程和线程的区别？" class="headerlink" title="一、进程和线程的区别？"></a>一、进程和线程的区别？</h1><pre><code>1.本质区别：    进程是资源调度、分配的基本单位。    线程是CPU调度、执行的基本单位。2.并发性：    进程并发性低（进程切换代价要大于线程切换，原因是进程切换涉及到用户级上下文的切换）。    线程并发性高。3.地址空间内存：    每个进程都有独立的虚拟内存地址空间。    线程没有，且同一进程内的所有线程共享该进程的内存资源。4.所属关系：    一个进程可以拥有多个线程。    一个线程只能属于某一个进程。5.健壮性：    进程异常不会影响其他进程，因此进程的健壮性更高。    线程异常可能导致整个进程崩溃（线程异常可能会影响进程的内存分布），因此线程健壮性低。</code></pre><h1 id="二、内存分布？"><a href="#二、内存分布？" class="headerlink" title="二、内存分布？"></a>二、内存分布？</h1><p><img src="https://pic.imgdb.cn/item/6624b29d0ea9cb1403f81c8f.png" alt="内存分布"></p><h1 id="三、什么是系统调用？"><a href="#三、什么是系统调用？" class="headerlink" title="三、什么是系统调用？"></a>三、什么是系统调用？</h1><h3 id="系统调用就是内核提供给用户级函数库的编程接口。"><a href="#系统调用就是内核提供给用户级函数库的编程接口。" class="headerlink" title="系统调用就是内核提供给用户级函数库的编程接口。"></a>系统调用就是内核提供给用户级函数库的编程接口。</h3><pre><code>reda()---&gt;sys_read()malloc()---&gt;brk()/mmap();由用户态切换到内核态：软中断 int 0X80.</code></pre><h1 id="四、系统调用会不会引起进程或线程切换？"><a href="#四、系统调用会不会引起进程或线程切换？" class="headerlink" title="四、系统调用会不会引起进程或线程切换？"></a>四、系统调用会不会引起进程或线程切换？</h1><pre><code>1.如果使用了阻塞IO，且IO未就绪，就会引起线程切换。2.如果使用了非阻塞IO，不会引起切换。</code></pre><h1 id="五、malloc函数是如何分配内存的？"><a href="#五、malloc函数是如何分配内存的？" class="headerlink" title="五、malloc函数是如何分配内存的？"></a>五、malloc函数是如何分配内存的？</h1><pre><code>malloc：    1.优先从内存池中分配，这样的话页面关系还在，可以减少系统调用和缺页异常。    2.分配空间 &lt; 128K时，brk系统调用，从堆区分配（↑）。    3.分配空间 ≥ 128K时，mmap系统调用，从文件映射段分配（↓）。        每次都会发生系统调用。        第一次访问肯定会触发缺页异常。</code></pre><h3 id="注意：malloc分配的是虚拟内存，只有访问时才会映射物理内存。"><a href="#注意：malloc分配的是虚拟内存，只有访问时才会映射物理内存。" class="headerlink" title="注意：malloc分配的是虚拟内存，只有访问时才会映射物理内存。"></a>注意：malloc分配的是虚拟内存，只有访问时才会映射物理内存。</h3><h1 id="六、free如何释放内存？如何确定要释放多大？"><a href="#六、free如何释放内存？如何确定要释放多大？" class="headerlink" title="六、free如何释放内存？如何确定要释放多大？"></a>六、free如何释放内存？如何确定要释放多大？</h1><pre><code>free(p);       P ------------------ | 16B | 分配的内存| ------------------分配空间时，系统会多分配16字节，这16字节描述分配的内存信息，其中包含分配的内存大小，释放时，P指针先左移16位。</code></pre><h3 id="1-若通过brk系统调用分配的内存，free不会立刻归还系统，而是放到内存池中供下次使用。"><a href="#1-若通过brk系统调用分配的内存，free不会立刻归还系统，而是放到内存池中供下次使用。" class="headerlink" title="1.若通过brk系统调用分配的内存，free不会立刻归还系统，而是放到内存池中供下次使用。"></a>1.若通过brk系统调用分配的内存，free不会立刻归还系统，而是放到内存池中供下次使用。</h3><h3 id="2-若通过mmap系统调用分配的内存，free会立刻归还系统。"><a href="#2-若通过mmap系统调用分配的内存，free会立刻归还系统。" class="headerlink" title="2.若通过mmap系统调用分配的内存，free会立刻归还系统。"></a>2.若通过mmap系统调用分配的内存，free会立刻归还系统。</h3><h1 id="七、什么是缺页异常？"><a href="#七、什么是缺页异常？" class="headerlink" title="七、什么是缺页异常？"></a>七、什么是缺页异常？</h1><h2 id="1-缺页异常"><a href="#1-缺页异常" class="headerlink" title="1.缺页异常"></a>1.缺页异常</h2><pre><code>1.CPU执行load m，找到m对应的页表项。2.若有效，则CPU直接访问物理内存，若无效，触发缺页异常。3.系统收到缺页异常，执行缺页异常处理函数，找到磁盘中的页面位置。4.把磁盘页面换入到物理内存中的空闲页。---------------------------&gt;页面置换算法5.修改页表项的状态为有效。</code></pre><h3 id="2-触发缺页异常"><a href="#2-触发缺页异常" class="headerlink" title="2.触发缺页异常"></a>2.触发缺页异常</h3><pre><code>1.虚拟内存---&gt;页表项---&gt;物理内存的映射关系不存在。2.页表项无效（可能换出到磁盘了）。3.页表项只读，现在要写。</code></pre><h3 id="3-页面置换"><a href="#3-页面置换" class="headerlink" title="3.页面置换"></a>3.页面置换</h3><pre><code>当需要将磁盘空间的页面换入到物理内存中时，若物理内存中没有空闲页，则需要将物理内存中的一个页面置换到磁盘，并设置该页面的页表项为无效，从而腾出一个空闲页来。</code></pre><h4 id="页面置换算法：尽量避免内存交换次数。"><a href="#页面置换算法：尽量避免内存交换次数。" class="headerlink" title="页面置换算法：尽量避免内存交换次数。"></a>页面置换算法：尽量避免内存交换次数。</h4><pre><code>最佳置换算法、最近最久未使用LRU、先进先出FIFO等。</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、进程和线程的区别？&quot;&gt;&lt;a href=&quot;#一、进程和线程的区别？&quot; class=&quot;headerlink&quot; title=&quot;一、进程和线程的区别？&quot;&gt;&lt;/a&gt;一、进程和线程的区别？&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;1.本质区别：

    进程是资源调度、分配的基本</summary>
      
    
    
    
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>C++</title>
    <link href="http://example.com/2024/04/21/C/"/>
    <id>http://example.com/2024/04/21/C/</id>
    <published>2024-04-21T03:50:37.000Z</published>
    <updated>2024-04-21T03:58:29.592Z</updated>
    
    
    
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>MySQL</title>
    <link href="http://example.com/2024/03/28/MySQL/"/>
    <id>http://example.com/2024/03/28/MySQL/</id>
    <published>2024-03-28T14:09:46.000Z</published>
    <updated>2024-04-19T08:05:51.862Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、什么是索引？"><a href="#一、什么是索引？" class="headerlink" title="一、什么是索引？"></a>一、什么是索引？</h1><pre><code>索引就是一种帮助MySQL高效获取数据的排好序的数据结构。</code></pre><h1 id="二、索引的数据结构有哪些？"><a href="#二、索引的数据结构有哪些？" class="headerlink" title="二、索引的数据结构有哪些？"></a>二、索引的数据结构有哪些？</h1><h2 id="1、二叉树"><a href="#1、二叉树" class="headerlink" title="1、二叉树"></a>1、二叉树</h2><pre><code>通常不采用，自增数据可能会导致退化成链表。</code></pre><h2 id="2、红黑树（二叉平衡树）"><a href="#2、红黑树（二叉平衡树）" class="headerlink" title="2、红黑树（二叉平衡树）"></a>2、红黑树（二叉平衡树）</h2><pre><code>通常不采用，数据量大时，层级高，查询效率低。</code></pre><h2 id="3、Hash-table"><a href="#3、Hash-table" class="headerlink" title="3、Hash table"></a>3、Hash table</h2><pre><code>（1）不支持范围查找（2）Hash 冲突问题</code></pre><h2 id="4、B-tree"><a href="#4、B-tree" class="headerlink" title="4、B tree"></a>4、B tree</h2><pre><code>每个page既有索引，又有数据</code></pre><h2 id="5、B-tree"><a href="#5、B-tree" class="headerlink" title="5、B+ tree"></a>5、B+ tree</h2><pre><code>MySQL采用的索引结构（1）叶子节点拥有全部索引字段。（2）非叶子节点只包含冗余索引，不包含数据。内存可以放更多的索引。（3）叶子节点之间由双向链表项链，且按照索引已经排好序，能很好地支持范围查找。</code></pre><p><img src="https://pic.imgdb.cn/item/6622233f0ea9cb14031ff82b.png"></p><h1 id="三、什么是聚簇索引和非聚簇索引？"><a href="#三、什么是聚簇索引和非聚簇索引？" class="headerlink" title="三、什么是聚簇索引和非聚簇索引？"></a>三、什么是聚簇索引和非聚簇索引？</h1><h2 id="1、MyISAM存储引擎——————非聚簇索引"><a href="#1、MyISAM存储引擎——————非聚簇索引" class="headerlink" title="1、MyISAM存储引擎——————非聚簇索引"></a>1、MyISAM存储引擎——————非聚簇索引</h2><pre><code>一张表有：.frm + .MYI + .MYD 三个文件1.叶子节点的data部分存的是该索引字段对应的磁盘地址。2.查询时，需要到.MYD中找到该磁盘地址对应的数据。（即回表操作）</code></pre><h2 id="2、InnoDB存储引擎——————聚簇索引"><a href="#2、InnoDB存储引擎——————聚簇索引" class="headerlink" title="2、InnoDB存储引擎——————聚簇索引"></a>2、InnoDB存储引擎——————聚簇索引</h2><pre><code>一张表有：.frm + .idb 两个文件叶子节点的data部分存储的时该索引对应的所在行的完整数据。（不需要回表操作）因此，聚簇索引的性能要高于非聚簇索引。</code></pre><h1 id="四、普通索引和主键索引的区别？"><a href="#四、普通索引和主键索引的区别？" class="headerlink" title="四、普通索引和主键索引的区别？"></a>四、普通索引和主键索引的区别？</h1><h2 id="1、普通索引："><a href="#1、普通索引：" class="headerlink" title="1、普通索引："></a>1、普通索引：</h2><pre><code>1.叶子节点data部分存放的是主键2.查找时，先利用普通索引找到主键，再利用主键索引找到对应的数据。（本质上也是非聚簇）</code></pre><h2 id="2、主键索引："><a href="#2、主键索引：" class="headerlink" title="2、主键索引："></a>2、主键索引：</h2><pre><code>1.叶子节点的data部分存放的是该索引字段所在行的完整数据。2.查找时，可直接找到对应数据返回。</code></pre><h1 id="五、什么是索引覆盖？"><a href="#五、什么是索引覆盖？" class="headerlink" title="五、什么是索引覆盖？"></a>五、什么是索引覆盖？</h1><pre><code>所查字段正好在所用索引字段中，可直接返回，无需进一步回表。</code></pre><h1 id="六、什么是索引描述？与全表扫描有什么区别？"><a href="#六、什么是索引描述？与全表扫描有什么区别？" class="headerlink" title="六、什么是索引描述？与全表扫描有什么区别？"></a>六、什么是索引描述？与全表扫描有什么区别？</h1><pre><code>1.索引扫描：扫描索引B+ tree的叶子节点。----扫描的节点可能更少，效率更高。2.扫描主键B+ tree的叶子节点。</code></pre><h1 id="七、什么情况会导致索引失效？"><a href="#七、什么情况会导致索引失效？" class="headerlink" title="七、什么情况会导致索引失效？"></a>七、什么情况会导致索引失效？</h1><pre><code>对字段进行操作时会导致索引失效比如：varchar类型转int类型时，&#39;a&#39; ---&gt; 0    &#39;1&#39; ---&gt; 1</code></pre><h1 id="八、如果不建主键索引，那么一张表该怎么维护呢？"><a href="#八、如果不建主键索引，那么一张表该怎么维护呢？" class="headerlink" title="八、如果不建主键索引，那么一张表该怎么维护呢？"></a>八、如果不建主键索引，那么一张表该怎么维护呢？</h1><pre><code>1.首先，会利用该表的第一个唯一索引，建立维护这张表。2.若没有唯一索引，会利用隐藏字段row_id来组织维护这张表。注意：row_id对外不开放，建议自行建立自增的主键索引（通常为int 或者 bigint）</code></pre><h1 id="九、什么是MySQL的最左前缀原则？"><a href="#九、什么是MySQL的最左前缀原则？" class="headerlink" title="九、什么是MySQL的最左前缀原则？"></a>九、什么是MySQL的最左前缀原则？</h1><pre><code>在联合索引时，要使某一个索引字段能高效查找，那么该索引字段的前几个索引一定要走了索引才行。注意：查看一个SQL语句有没有走索引，可以用 EXPLAIN 查看。</code></pre><h1 id="十、什么是事务？"><a href="#十、什么是事务？" class="headerlink" title="十、什么是事务？"></a>十、什么是事务？</h1><pre><code>一组操作要么全部成功，要么全部失败，目的时为了保证数据的最终一致性。</code></pre><h1 id="十一、事务有哪些特性？分别是什么？"><a href="#十一、事务有哪些特性？分别是什么？" class="headerlink" title="十一、事务有哪些特性？分别是什么？"></a>十一、事务有哪些特性？分别是什么？</h1><pre><code>ACID：原子性、一致性、隔离性、持久性1.原子性：当前事务的操作，要么同时成功，要么同时失败。原子性由undo log保证。2.一致性：使用事务的最终目的。3.隔离性：事务并发执行时，事务之间的操作不能互相干扰。4.持久性：一个事务一旦提交，它对数据库的改变就应当时永久性的。持久性由redo log保证</code></pre><h1 id="十二、事务隔离级别有哪些？"><a href="#十二、事务隔离级别有哪些？" class="headerlink" title="十二、事务隔离级别有哪些？"></a>十二、事务隔离级别有哪些？</h1><pre><code>                脏读        不可重复读          幻读读未提交          ×              ×               ×           读已提交          √              ×               ×       -----MVCC，每次查询都会创建快照可重复读          √              √               ×       -----MVCC，同样的查询只会在第一次查询时创建快照串行化            √              √               √       -----利用表锁MySQL默认是 可重复读级别</code></pre><h1 id="十三、MVCC机制是什么？"><a href="#十三、MVCC机制是什么？" class="headerlink" title="十三、MVCC机制是什么？"></a>十三、MVCC机制是什么？</h1><pre><code>MVCC机制-----多版本并发控制机制。1.底层原理：Copy On Write-----COW，写时复制2.具体实现：内部维护了一个 undo log 日志版本链，通过快照可以找到对应版本的数据。</code></pre><p><img src="https://pic.imgdb.cn/item/662224490ea9cb1403220232.png"></p><h1 id="十四、什么是事务的持久性？"><a href="#十四、什么是事务的持久性？" class="headerlink" title="十四、什么是事务的持久性？"></a>十四、什么是事务的持久性？</h1><pre><code>事务的持久性主要是依靠redo log来维护的。1.Buffer Pool内存写完后，会先写一份redo log，这份redo log会记录这次的物理修改（在某个页上做了什么修改），即便MySQL在中途挂了，也可以根据redo log对数据进行恢复。2.redo log是顺序写的，写入速度很快，并且它记录的是物理修改，文件体积比较小，恢复速度很快。</code></pre><p><img src="https://pic.imgdb.cn/item/662224f30ea9cb140325b58d.webp"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、什么是索引？&quot;&gt;&lt;a href=&quot;#一、什么是索引？&quot; class=&quot;headerlink&quot; title=&quot;一、什么是索引？&quot;&gt;&lt;/a&gt;一、什么是索引？&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;索引就是一种帮助MySQL高效获取数据的排好序的数据结构。
&lt;/code&gt;&lt;</summary>
      
    
    
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="http://example.com/2024/03/28/Redis/"/>
    <id>http://example.com/2024/03/28/Redis/</id>
    <published>2024-03-28T14:09:34.000Z</published>
    <updated>2024-04-19T08:59:09.111Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、为什么引入Redis缓存？有什么好处？"><a href="#一、为什么引入Redis缓存？有什么好处？" class="headerlink" title="一、为什么引入Redis缓存？有什么好处？"></a>一、为什么引入Redis缓存？有什么好处？</h1><pre><code>Redis是基于内存的，支持上万的并发，存一些热点数据和频繁访问的数据，可以为MySQL分流，进而提高性能。</code></pre><h1 id="二、Redis为什么这么快？"><a href="#二、Redis为什么这么快？" class="headerlink" title="二、Redis为什么这么快？"></a>二、Redis为什么这么快？</h1><h3 id="1-首先Redis是基于纯内存操作，因此访问速度快。"><a href="#1-首先Redis是基于纯内存操作，因此访问速度快。" class="headerlink" title="1.首先Redis是基于纯内存操作，因此访问速度快。"></a>1.首先Redis是基于纯内存操作，因此访问速度快。</h3><h3 id="2-Redis的线程模型："><a href="#2-Redis的线程模型：" class="headerlink" title="2.Redis的线程模型："></a>2.Redis的线程模型：</h3><pre><code>1.采用IO多路复用，同时监听多个socket。2.内部维护了一个文件时间分派器，可以根据不同的socket事件状态，分派给不同的处理器（连接应答处理器、命令请求处理器、命令回复处理器），不同处理器之间可以并发的进行处理。</code></pre><h1 id="三、Redis的过期策略？"><a href="#三、Redis的过期策略？" class="headerlink" title="三、Redis的过期策略？"></a>三、Redis的过期策略？</h1><pre><code>1.惰性删除：只有访问key时，才会删除。---对cpu友好，对内存不友好。2.定期删除：每隔一段时间去检查，抽取一部分设置了过期时间的key，若过期则删除。---对内存友好，对cpu不友好。</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Redis是惰性删除 + 定期删除结合使用，使cpu和内存达到一个较好的平衡。</span><br></pre></td></tr></table></figure><h1 id="四、什么是Redis的淘汰策略？"><a href="#四、什么是Redis的淘汰策略？" class="headerlink" title="四、什么是Redis的淘汰策略？"></a>四、什么是Redis的淘汰策略？</h1><pre><code>1.Redis的过期策略可能会漏掉一些过期的key，这些key积压在内存中，可能导致内存溢出，因此需要淘汰策略。2.淘汰策略：允许内存紧张时，根据一定的淘汰策略删除一些key-value对，以释放内存空间。3.常见淘汰策略：不淘汰策略、最近最少使用LRU、过期时间最短、随机删除、全局LRU、全局随机删除等。</code></pre><h1 id="五、什么是Redis的哨兵机制？有什么作用？"><a href="#五、什么是Redis的哨兵机制？有什么作用？" class="headerlink" title="五、什么是Redis的哨兵机制？有什么作用？"></a>五、什么是Redis的哨兵机制？有什么作用？</h1><pre><code>1.首先，Redis为了避免单机宕机情况的出现，一般采用集群不是（主-从）。2.哨兵集群是用来监控Redis集群的，若多个哨兵节点均认为某一个Redis节点宕机，则会在内部进行哨兵选举，当选的哨兵节点会主导Redis节点的切换，避免长时间宕机带来的风险。</code></pre><h1 id="六、什么是Redis缓存击穿、缓存雪崩、缓存穿透？如何避免和解决？"><a href="#六、什么是Redis缓存击穿、缓存雪崩、缓存穿透？如何避免和解决？" class="headerlink" title="六、什么是Redis缓存击穿、缓存雪崩、缓存穿透？如何避免和解决？"></a>六、什么是Redis缓存击穿、缓存雪崩、缓存穿透？如何避免和解决？</h1><h2 id="1-缓存击穿"><a href="#1-缓存击穿" class="headerlink" title="1.缓存击穿"></a>1.缓存击穿</h2><h3 id="指在高并发访问下，某一个热点数据失效了，针对该热点数据的大量请求就会直接达到MySQL，使MySQL压力剧增。"><a href="#指在高并发访问下，某一个热点数据失效了，针对该热点数据的大量请求就会直接达到MySQL，使MySQL压力剧增。" class="headerlink" title="指在高并发访问下，某一个热点数据失效了，针对该热点数据的大量请求就会直接达到MySQL，使MySQL压力剧增。"></a>指在高并发访问下，某一个热点数据失效了，针对该热点数据的大量请求就会直接达到MySQL，使MySQL压力剧增。</h3><pre><code>解决方案：    1.对热点数据的过期时间适当延长or设置永不过期。    2.互斥锁访问MySQL。</code></pre><h2 id="2-缓存雪崩"><a href="#2-缓存雪崩" class="headerlink" title="2.缓存雪崩"></a>2.缓存雪崩</h2><h3 id="指在高并发访问下，大量缓存数据同时失效，导致大量请求涌入MySQL，使MySQL压力据曾，甚至宕机。"><a href="#指在高并发访问下，大量缓存数据同时失效，导致大量请求涌入MySQL，使MySQL压力据曾，甚至宕机。" class="headerlink" title="指在高并发访问下，大量缓存数据同时失效，导致大量请求涌入MySQL，使MySQL压力据曾，甚至宕机。"></a>指在高并发访问下，大量缓存数据同时失效，导致大量请求涌入MySQL，使MySQL压力据曾，甚至宕机。</h3><pre><code>解决方案：    1.对不同的key设置间隔缓过期时间， key1---5min， key2---10min， key3---15min。    2.互斥锁访问MySQL。    3.多级缓存。 如 本地缓存 + 分布式缓存。    4.缓存集群部署。如 主-从缓存集群。</code></pre><h2 id="3-缓存穿透"><a href="#3-缓存穿透" class="headerlink" title="3.缓存穿透"></a>3.缓存穿透</h2><h3 id="指大量恶意请求访问Redis和MySQL中都没有的数据，影像数据库性能。"><a href="#指大量恶意请求访问Redis和MySQL中都没有的数据，影像数据库性能。" class="headerlink" title="指大量恶意请求访问Redis和MySQL中都没有的数据，影像数据库性能。"></a>指大量恶意请求访问Redis和MySQL中都没有的数据，影像数据库性能。</h3><pre><code>解决方案：    1.缓存空数据。注意合理把控空数据对应的失效时间，以免影像后续该空数据对应key的更新。    2.参数校验。过滤一些恶意请求中的非法参数。    3.布隆过滤器（黑白名单）：可以快速判断某个元素是否属于该集合。</code></pre><h1 id="七、Redis持久化机制？"><a href="#七、Redis持久化机制？" class="headerlink" title="七、Redis持久化机制？"></a>七、Redis持久化机制？</h1><pre><code>RDB：内存快照AOF：增量日志</code></pre><h3 id="1-RDB内存快照持久化机制"><a href="#1-RDB内存快照持久化机制" class="headerlink" title="1.RDB内存快照持久化机制"></a>1.RDB内存快照持久化机制</h3><pre><code>在指定时间间隔内，将内存中的数据快照写入磁盘，以二进制序列化形式进行数据的全量备份。1.优点：    （1）恢复速度快。    （2）文件紧凑：rdb文件是一个二进制数据库文件，相比aof文件体积更小。2.缺点：可能会丢失数据    快照1--------Redis宕机-------快照2Redis默认是开启RDB持久化机制的，AOF持久化机制需要手动开启。</code></pre><h3 id="2-AOF增量日志持久化机制"><a href="#2-AOF增量日志持久化机制" class="headerlink" title="2.AOF增量日志持久化机制"></a>2.AOF增量日志持久化机制</h3><pre><code>写请求---&gt;AOF缓冲池---&gt;（同步策略 刷1次数据/s）---&gt;.incr.aof文件---&gt;（触发AOF重写）---&gt;.base.aof文件，并清空.incr.aof文件恢复数据时，先利用.base.aof文件恢复，然后恢复.incr.aof文件（清空后可能又有新的数据）1.优点：    数据更加可靠。aof文件记录了每一个写请求。2.缺点：    文件体积大，恢复速度慢。|---.incr.aof文件----|----.base.aof文件--------|</code></pre><h3 id="建议：RDB-AOF"><a href="#建议：RDB-AOF" class="headerlink" title="建议：RDB + AOF"></a>建议：RDB + AOF</h3><pre><code>触发AOF重写时，将.aof文件数据直接写入到一个.rdb二进制文件。恢复数据时，先回复.rdb文件，再恢复.aof文件。|------.rdb文件------|-------.aof文件----------|</code></pre><h1 id="八、如何保证Redis与数据库的数据一致性？"><a href="#八、如何保证Redis与数据库的数据一致性？" class="headerlink" title="八、如何保证Redis与数据库的数据一致性？"></a>八、如何保证Redis与数据库的数据一致性？</h1><h3 id="1-先操作缓存：延时双删"><a href="#1-先操作缓存：延时双删" class="headerlink" title="1.先操作缓存：延时双删"></a>1.先操作缓存：延时双删</h3><h3 id="2-先操作数据库：（推荐）"><a href="#2-先操作数据库：（推荐）" class="headerlink" title="2.先操作数据库：（推荐）"></a>2.先操作数据库：（推荐）</h3><h3 id="两种方法都是为了保证数据的最终一致性。"><a href="#两种方法都是为了保证数据的最终一致性。" class="headerlink" title="两种方法都是为了保证数据的最终一致性。"></a>两种方法都是为了保证数据的最终一致性。</h3><h1 id="九、删除缓存的时候失败了怎么办呢？"><a href="#九、删除缓存的时候失败了怎么办呢？" class="headerlink" title="九、删除缓存的时候失败了怎么办呢？"></a>九、删除缓存的时候失败了怎么办呢？</h1><pre><code>1.利用MQ中间件执行异步删除重试。2.利用Canal进行逻辑解耦，将删除缓存的操作放到Canal客户端。</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、为什么引入Redis缓存？有什么好处？&quot;&gt;&lt;a href=&quot;#一、为什么引入Redis缓存？有什么好处？&quot; class=&quot;headerlink&quot; title=&quot;一、为什么引入Redis缓存？有什么好处？&quot;&gt;&lt;/a&gt;一、为什么引入Redis缓存？有什么好处？&lt;/</summary>
      
    
    
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://example.com/2024/03/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2024/03/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2024-03-28T14:09:19.000Z</published>
    <updated>2024-04-19T09:19:01.110Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、单例模式"><a href="#一、单例模式" class="headerlink" title="一、单例模式"></a>一、单例模式</h1><pre><code>一个类只能有一个实例，并对外开放一个公共的访问接口。分为懒汉模式和饿汉模式，其中饿汉模式没有线程安全问题，懒汉模式有。</code></pre><h3 id="1-饿汉模式"><a href="#1-饿汉模式" class="headerlink" title="1.饿汉模式"></a>1.饿汉模式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> A* <span class="title">get_instence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> A* my_instance;</span><br><span class="line">        <span class="keyword">return</span> my_instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">my_print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;i am singalton instance...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a = A::<span class="built_in">get_instance</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-懒汉模式实现线程安全单例模式思路：3种"><a href="#2-懒汉模式实现线程安全单例模式思路：3种" class="headerlink" title="2.懒汉模式实现线程安全单例模式思路：3种"></a>2.懒汉模式实现线程安全单例模式思路：3种</h3><pre><code>1.静态局部变量</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> A* <span class="title">get_instence</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> A* my_instance;</span><br><span class="line">        <span class="keyword">return</span> my_instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">my_print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;i am singalton instance...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a = A::<span class="built_in">get_instance</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>2.双重检查锁 + 原子变量</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、单例模式&quot;&gt;&lt;a href=&quot;#一、单例模式&quot; class=&quot;headerlink&quot; title=&quot;一、单例模式&quot;&gt;&lt;/a&gt;一、单例模式&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;一个类只能有一个实例，并对外开放一个公共的访问接口。
分为懒汉模式和饿汉模式，其中饿汉模式没</summary>
      
    
    
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>MySQL锁机制</title>
    <link href="http://example.com/2024/03/26/MySQL%E9%94%81%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/2024/03/26/MySQL%E9%94%81%E6%9C%BA%E5%88%B6/</id>
    <published>2024-03-26T13:53:23.000Z</published>
    <updated>2024-04-21T03:48:42.635Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="一、从粒度上区分"><a href="#一、从粒度上区分" class="headerlink" title="一、从粒度上区分"></a>一、从粒度上区分</h1><h2 id="（一）全局锁—–-针对整个数据库"><a href="#（一）全局锁—–-针对整个数据库" class="headerlink" title="（一）全局锁—–&gt;针对整个数据库"></a>（一）全局锁—–&gt;针对整个数据库</h2><h3 id="1-读锁（共享锁）"><a href="#1-读锁（共享锁）" class="headerlink" title="1.读锁（共享锁）"></a>1.读锁（共享锁）</h3><pre><code>作用：阻止更新数据，但允许读取数据。用途：可以在一段时间内保持数据一致性。</code></pre><h3 id="2-写锁（排他锁）"><a href="#2-写锁（排他锁）" class="headerlink" title="2.写锁（排他锁）"></a>2.写锁（排他锁）</h3><pre><code>作用：阻止更新数据、读取数据。用途：需要大量更新数据时。</code></pre><h2 id="（二）表级锁—–-针对整张表"><a href="#（二）表级锁—–-针对整张表" class="headerlink" title="（二）表级锁—–&gt;针对整张表"></a>（二）表级锁—–&gt;针对整张表</h2><h3 id="1-表读锁（表共享锁）"><a href="#1-表读锁（表共享锁）" class="headerlink" title="1.表读锁（表共享锁）"></a>1.表读锁（表共享锁）</h3><pre><code>作用：不能写，但可以读，读锁之间不会相互阻塞。用途：适合读频繁，写不频繁的场景。</code></pre><h3 id="2-表写锁（表独占锁）"><a href="#2-表写锁（表独占锁）" class="headerlink" title="2.表写锁（表独占锁）"></a>2.表写锁（表独占锁）</h3><pre><code>作用：表写锁会阻塞其他所有锁。用途：一般用于全表更新时。</code></pre><h3 id="3-表级锁的风险"><a href="#3-表级锁的风险" class="headerlink" title="3.表级锁的风险"></a>3.表级锁的风险</h3><pre><code>1.性能下降：高并发场景下，对于读写密度混合的负载，表级锁可能会成为性能瓶颈。2.并发性能差：读锁不能写，写锁既不能读也不能写。3.锁等待、锁超时：高并发场景下，很多线程等待锁，可能导致锁超时。4.写操作影响性能较大。5.死锁：表级锁本身不会出现死锁，但在多表操作种，若没有按一定顺序获得锁，则可能导致死锁。</code></pre><h3 id="4-不同存储引擎的锁"><a href="#4-不同存储引擎的锁" class="headerlink" title="4.不同存储引擎的锁"></a>4.不同存储引擎的锁</h3><pre><code>1.MyISAM存储引擎：读操作----自动加读锁，写操作----自动加写锁。2.InnoDB存储引擎：主要使用行锁实现MVCC机制，非必要情况不适用表级锁。    更好的并发性能，更少的锁冲突。</code></pre><h2 id="（三）行级锁-（主要由InnoDB提供）—–-针对某行数据"><a href="#（三）行级锁-（主要由InnoDB提供）—–-针对某行数据" class="headerlink" title="（三）行级锁*（主要由InnoDB提供）—–&gt;针对某行数据"></a>（三）行级锁*（主要由InnoDB提供）—–&gt;针对某行数据</h2><h3 id="1-行读锁（S锁）"><a href="#1-行读锁（S锁）" class="headerlink" title="1.行读锁（S锁）"></a>1.行读锁（S锁）</h3><pre><code>事务S锁某行数据后，该行数据只能读，不能写。</code></pre><h3 id="2-行写锁（X锁）"><a href="#2-行写锁（X锁）" class="headerlink" title="2.行写锁（X锁）"></a>2.行写锁（X锁）</h3><pre><code>事务X锁某行数据后，该行数据既不能读，也不能写。</code></pre><h3 id="3-行级锁风险"><a href="#3-行级锁风险" class="headerlink" title="3.行级锁风险"></a>3.行级锁风险</h3><pre><code>1.死锁：行级锁粒度最低，导致死锁发生的可能更高。死锁发生时，MySQL会释放其中一个事务，但影响性能。2.锁升级：一个事务试图锁定的行过多，InnoDB可能会将该行级锁升级为表级锁。3.锁等待：高并发时，如果对热点数据上了锁，可能会导致锁等待和锁超时。4.资源消耗大：行级锁需要更多的内存来存储锁信息，以及更多的CPU时间处理锁请求/释放锁。5.难调试，难排查：行锁粒度最小。6.事务隔离级别：不同的隔离级别会影响行锁性能。</code></pre><h1 id="二、从模式上区分"><a href="#二、从模式上区分" class="headerlink" title="二、从模式上区分"></a>二、从模式上区分</h1><h2 id="（一）乐观锁"><a href="#（一）乐观锁" class="headerlink" title="（一）乐观锁"></a>（一）乐观锁</h2><pre><code>1.使用方法：利用版本号字段，每当一条记录被修改时，增加版本号字段。2.思想：操作数据不立即锁定，提交时检查版本号是否与开始时一致，若一致，则提交（commit），否则，回滚（rollback）。</code></pre><h2 id="（二）悲观锁"><a href="#（二）悲观锁" class="headerlink" title="（二）悲观锁"></a>（二）悲观锁</h2><pre><code>1.使用方法：    S锁：lock in share mode；    X锁：for update；2.优缺点：    优点：能够有效防止数据冲突。    缺点：死锁、锁超时、锁竞争。3.使用场景：    适合数据需要保持强一致性的场景：如银行帐目等。</code></pre><h2 id="（三）意向锁（实际上就是表级锁）"><a href="#（三）意向锁（实际上就是表级锁）" class="headerlink" title="（三）意向锁（实际上就是表级锁）"></a>（三）意向锁（实际上就是表级锁）</h2><pre><code>意向锁支持表级锁、行级锁共存。            意向共享锁（IS锁）          意向排他锁（IX锁）</code></pre><p>共享锁（S锁）         兼容                       互斥</p><p>排他锁（X锁）         互斥                       互斥</p><h1 id="三、从区间上区分"><a href="#三、从区间上区分" class="headerlink" title="三、从区间上区分"></a>三、从区间上区分</h1><h2 id="（一）临键锁—–-解决幻读问题"><a href="#（一）临键锁—–-解决幻读问题" class="headerlink" title="（一）临键锁—–&gt;解决幻读问题"></a>（一）临键锁—–&gt;解决幻读问题</h2><pre><code>1.非索引字段上都会有一把临键锁。2.事务持有该行临键锁，会锁住一段左开右闭的数据。3.InnoDB存储引擎中，唯一索引字段与主键索引字段不存在临键锁。</code></pre><h2 id="（二）间隙锁—–-解决幻读问题"><a href="#（二）间隙锁—–-解决幻读问题" class="headerlink" title="（二）间隙锁—–&gt;解决幻读问题"></a>（二）间隙锁—–&gt;解决幻读问题</h2><pre><code>幻读问题：表级问题。    事务A读取：10， 20， 30.                                                                事务B插入：10, 15, 20, 30.        事务A读取：10, 15, 20, 30. ------&gt;幻读 15.</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h1 id=&quot;一、从粒度上区分&quot;&gt;&lt;a href=&quot;#一、从粒度上区分&quot; class=&quot;headerlink&quot; title=&quot;一、从粒度上区分&quot;&gt;&lt;/a&gt;一、从粒度上区分&lt;/h1&gt;&lt;h2 id=&quot;（一）全局锁—–-针对整个数据库</summary>
      
    
    
    
    
    <category term="MySQL锁机制" scheme="http://example.com/tags/MySQL%E9%94%81%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>网络编程</title>
    <link href="http://example.com/2024/03/08/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>http://example.com/2024/03/08/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</id>
    <published>2024-03-08T08:53:52.000Z</published>
    <updated>2024-03-21T04:00:19.296Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2024/03/08/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/wangluobiancheng.jpg"></p><span id="more"></span><h1 id="一、阻塞IO（BIO）和非阻塞IO（NIO）"><a href="#一、阻塞IO（BIO）和非阻塞IO（NIO）" class="headerlink" title="一、阻塞IO（BIO）和非阻塞IO（NIO）"></a>一、阻塞IO（BIO）和非阻塞IO（NIO）</h1><p><font color="red" size="5" face="楷体">什么是阻塞IO？</font></p><pre><code>阻塞IO是一种传统的IO模型，当程序执行输入/输出操作时，会发生阻塞直到操作完成。当读取数据时，如果没有数据可读，那么进程会一直等待数据的到来；当写数据时，如果无法立即写入，进程将一直等待操作系统的信号，直到完成写操作。</code></pre><p><font color="green" size="4" face="楷体">【总结】 阻塞IO再进行IO操作时会阻塞进程，适用于应用程序IO请求较少且数据量较少的情况。</font></p><p><font color="red" size="5" face="楷体">什么是非阻塞阻塞IO？</font></p><pre><code>非阻塞IO是一种传统的IO模型，它允许程序在执行IO操作时继续执行其他任务。当读取数据时，如果没有数据可读，函数将立即返回一个错误码；当写入数据时，如果无法立即将数据写入目标，函数将立即返回一个错误码。通过轮询或选择机制，可以确定是否有数据可读或可写。</code></pre><p><font color="green" size="4" face="楷体">【总结】 非阻塞IO允许程序在执行IO操作时继续执行其它任务，通过轮询机制判断IO操作是否就绪。</font></p><p><font color="red" size="5" face="楷体">如何设置非阻塞？</font></p><p><font color="green" size="4" face="楷体">1、通过socket()中的SOCK_NOBLOCK参数设置<br>2、通过fcntl()函数设置O_NONBLOCK标志位设置</font></p><h1 id="二、IO多路复用"><a href="#二、IO多路复用" class="headerlink" title="二、IO多路复用"></a>二、IO多路复用</h1><p><font color="red" size="5" face="楷体">什么是IO多路复用？</font></p><p><font color="green" size="4" face="楷体">IO多路复用就是单线程&#x2F;单进程同时监听多个文件描述符的IO事件</font></p><p><font color="red" size="5" face="楷体">什么是select？</font></p><p><font color="green" size="4" face="楷体">IO多路复用就是单线程&#x2F;单进程同时监听多个文件描述符的IO事件</font></p><p><font color="red" size="5" face="楷体">什么是poll？</font></p><p><font color="red" size="5" face="楷体">什么是epoll？</font></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2024/03/08/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/wangluobiancheng.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="网络编程" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>十大排序算法</title>
    <link href="http://example.com/2024/02/28/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2024/02/28/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2024-02-28T09:27:54.000Z</published>
    <updated>2024-03-09T10:12:57.893Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2024/02/28/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/sort.jpg"></p><span id="more"></span><h1 id="一、冒泡排序"><a href="#一、冒泡排序" class="headerlink" title="一、冒泡排序"></a>一、冒泡排序</h1><p><font color="green" size="5" face="楷体">两两比较，大的后移，若有n个元素，则需要比较n-1轮，每一轮找出最大的元素</font></p><p><font color="orange" size="5" face="楷体">【优化策略】使用flag标志，一轮中若没有出现交换元素，则提前退出排序</font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> flag = <span class="number">0</span>;   <span class="comment">//添加flag标志位</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;排序前：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; i : v) &#123;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//-----------------------冒泡排序-----------------------</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; v.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (v[j - <span class="number">1</span>] &gt; v[j]) &#123;</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">temp = v[j - <span class="number">1</span>];</span><br><span class="line">v[j - <span class="number">1</span>] = v[j];</span><br><span class="line">v[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag == <span class="number">0</span>) <span class="keyword">break</span>;   <span class="comment">//flag没有变1，则退出。</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//------------------------------------------------------</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;排序后：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : v) &#123;</span><br><span class="line">cout &lt;&lt; i&lt;&lt;<span class="string">&quot;  &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="二、选择排序"><a href="#二、选择排序" class="headerlink" title="二、选择排序"></a>二、选择排序</h1><p><font color="green" size="5" face="楷体">从头开始扫描序列，找出最小的一个元素，与第一个元素交换，再从剩下的序列继续执行该方式，每一轮都能找到最小的元素</font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;排序前：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; i : v) &#123;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">//-----------------------选择排序-----------------------</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> min_index = i;</span><br><span class="line">        <span class="type">int</span> max_index = v.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; v.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (v[j] &lt; v[min_index]) &#123;</span><br><span class="line">min_index = j;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="keyword">if</span> (v[j] &gt; v[max_index]) &#123;</span><br><span class="line">                max_index = j;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (min_index != i) &#123;</span><br><span class="line">temp = v[i];</span><br><span class="line">v[i] = v[min_index];</span><br><span class="line">v[min_index] = temp;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">if</span> (max_index != v.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">            temp = v[v.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">            v[v.<span class="built_in">size</span>() - <span class="number">1</span>] = v[max_index];</span><br><span class="line">            v[max_index] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//------------------------------------------------------</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;排序后：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : v) &#123;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><font color="orange" size="5" face="楷体">【优化策略】一轮排序中，同时找出最小和最大，注意！！防止最大的元素是第一个，被换到了最小的位置上去</font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;排序前：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; i : v) &#123;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------------选择排序-----------------------</span></span><br><span class="line"><span class="type">int</span> left = <span class="number">0</span>, right = v.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line"><span class="type">int</span> min_index = left;</span><br><span class="line"><span class="type">int</span> max_index = right;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = left; i &lt;= right; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (v[i] &lt; v[min_index]) &#123;</span><br><span class="line">min_index = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (v[i] &gt; v[max_index]) &#123;</span><br><span class="line">max_index = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (min_index != left) <span class="built_in">swap</span>(v[left], v[min_index]);</span><br><span class="line">        <span class="comment">//防止最大的元素是第一个，被上一步if换到了最小的位置上去！</span></span><br><span class="line"><span class="keyword">if</span> (max_index == left) max_index = min_index；</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (max_index != right) <span class="built_in">swap</span>(v[right], v[max_index]);</span><br><span class="line"></span><br><span class="line">left++;</span><br><span class="line">right--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//------------------------------------------------------</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;排序后：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : v) &#123;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、插入排序-（纸牌排序）"><a href="#三、插入排序-（纸牌排序）" class="headerlink" title="三、插入排序 （纸牌排序）"></a>三、插入排序 （纸牌排序）</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">10</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;排序前：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; i : v) &#123;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">//-------------------------------插入排序---------------------------</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; v.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line"><span class="type">int</span> temp = v[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line"><span class="keyword">if</span> (temp &lt;= v[j]) &#123;</span><br><span class="line"><span class="comment">//后移</span></span><br><span class="line">v[j + <span class="number">1</span>] = v[j];</span><br><span class="line">v[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (temp &gt; v[j]) &#123;</span><br><span class="line">v[j + <span class="number">1</span>] = temp;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//------------------------------------------------------------------</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;排序后：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; i : v) &#123;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="red" size="5" face="楷体">【两个不足】<br>1、寻找插入位置<br>2、移动元素</font></p><p><font color="orange" size="5" face="楷体">【优化策略】<br>1、对已经排好序的序列，采用二分查找法<br>2、一次携带多个元素<br>3、数据链表化<br>4、希尔排序</font></p><h1 id="四、希尔排序"><a href="#四、希尔排序" class="headerlink" title="四、希尔排序"></a>四、希尔排序</h1><p><font color="green" size="5" face="楷体"> 希尔排序原理是每一对分组进行排序后，整个数据就会更接近有序，<font color="red" size="5" face="楷体">当增量缩小为1时，就是插入排序</font>，但是现在的数组非常接近有序，移动的数据很少，所以效率非常高，所以希尔排序又叫缩小增量排序。 </font></p><p><font color="orange" size="5" face="楷体"> 【核心思想】<br>化远为近：1、减少查找次数 2、减少元素移动次数 </font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">10</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">0</span>&#125;;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;排序前：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; i : v) &#123;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">//---------------------------希尔排序-------------------------------</span></span><br><span class="line"><span class="type">int</span> N = v.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> gap = N / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (gap &gt;= <span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">// 外循环：让gap到N-1的 所有元素乘上gap飞机</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = gap; i &lt; N; ++i) &#123;</span><br><span class="line"><span class="comment">//内循环： 每个元素是否需要向前跳跃</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i; j &gt;= gap &amp;&amp; v[j] &lt; v[j - gap]; j -= gap) &#123;</span><br><span class="line"><span class="built_in">swap</span>(v[j], v[j - gap]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">gap = gap / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//------------------------------------------------------------------</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;排序后：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; i : v) &#123;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五、快速排序"><a href="#五、快速排序" class="headerlink" title="五、快速排序"></a>五、快速排序</h1><p><font color="orange" size="5" face="楷体"> 【核心思想】挖坑填数，分治 </font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找划分位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp; v, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> pivot = v[low];</span><br><span class="line"><span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line"><span class="keyword">while</span> (low &lt; high &amp;&amp; v[high] &gt; pivot) &#123;</span><br><span class="line">high--;</span><br><span class="line">&#125;</span><br><span class="line">v[low] = v[high];</span><br><span class="line"><span class="keyword">while</span> (low &lt; high &amp;&amp; v[low] &lt; pivot) &#123;</span><br><span class="line">low++;</span><br><span class="line">&#125;</span><br><span class="line">v[high] = v[low];</span><br><span class="line">&#125;</span><br><span class="line">v[low] = pivot;<span class="comment">//v[high] = pivot也行</span></span><br><span class="line"><span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 快速排序逻辑（回溯）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line"><span class="type">int</span> pivot_pos = <span class="built_in">partition</span>(v, low, high);</span><br><span class="line"><span class="built_in">QuickSort</span>(v, low, pivot_pos - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">QuickSort</span>(v, pivot_pos + <span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">10</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">4</span>&#125;;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;排序前：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; i : v) &#123;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line"><span class="built_in">QuickSort</span>(v, <span class="number">0</span>, v.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;排序后：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; i : v) &#123;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="六、归并排序"><a href="#六、归并排序" class="headerlink" title="六、归并排序"></a>六、归并排序</h1><p><font color="orange" size="5" face="楷体"> 【核心思想】 先划分成单个数（单个数一定有序），再合并排序。 </font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp; v, vector&lt;<span class="type">int</span>&gt;&amp; temp, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> l_pos = left;</span><br><span class="line"><span class="type">int</span> r_pos = mid + <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> pos = left;</span><br><span class="line"><span class="keyword">while</span> (l_pos &lt;= mid &amp;&amp; r_pos &lt;= right) &#123;</span><br><span class="line"><span class="keyword">if</span> (v[l_pos] &lt; v[r_pos]) &#123;</span><br><span class="line">temp[pos++] = v[l_pos++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">temp[pos++] = v[r_pos++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将左半区剩余元素直接拿下来</span></span><br><span class="line"><span class="keyword">while</span> (l_pos &lt;= mid) &#123;</span><br><span class="line">temp[pos++] = v[l_pos++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将右半区剩余元素直接拿下来</span></span><br><span class="line"><span class="keyword">while</span> (r_pos &lt;= right) &#123;</span><br><span class="line">temp[pos++]= v[r_pos++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将临时数组中的元素拷贝到原数组</span></span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">v[left] = temp[left];</span><br><span class="line">left++;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mysort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v, vector&lt;<span class="type">int</span>&gt;&amp; temp, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line"><span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="built_in">mysort</span>(v, temp, <span class="number">0</span>, mid);</span><br><span class="line"><span class="built_in">mysort</span>(v, temp, mid + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line"><span class="built_in">merge</span>(v, temp, left, mid, right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 归并排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="comment">//申请的临时数组</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">temp</span><span class="params">(v.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (v.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">mysort</span>(v, temp, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 释放临时数组</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">swap</span>(temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">10</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span>&#125;;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;排序前：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; i : v) &#123;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">//----------------------------------------------------</span></span><br><span class="line"><span class="built_in">merge_sort</span>(v, v.<span class="built_in">size</span>());</span><br><span class="line"><span class="comment">//----------------------------------------------------</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;排序后：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; i : v) &#123;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="七、堆排序"><a href="#七、堆排序" class="headerlink" title="七、堆排序"></a>七、堆排序</h1><p><font color="orange" size="5" face="楷体"> 【核心思想】 维护堆、建堆、排序 </font></p><p><font color="orange" size="4" face="楷体"> 大顶堆：父节点 &gt;&#x3D; 左右子节点  </font></p><p><font color="orange" size="4" face="楷体"> 第i个节点的父节点下标：（i-1）&#x2F; 2；<br>第i个节点的左孩子下标：2<em>i+1；<br>第i个节点的右孩子下标：2</em>i+2；  </font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 维护堆</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapif</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v, <span class="type">int</span> n, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> largest = i;</span><br><span class="line"><span class="type">int</span> lson = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> rson = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (lson &lt; n &amp;&amp; v[lson] &gt; v[largest]) &#123;</span><br><span class="line">largest = lson;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (rson &lt; n &amp;&amp; v[rson] &gt; v[largest]) &#123;</span><br><span class="line">largest = rson;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line"><span class="built_in">swap</span>(v[largest], v[i]);</span><br><span class="line"><span class="built_in">heapif</span>(v, n, largest);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 堆排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 建堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = (n - <span class="number">1</span> - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line"><span class="built_in">heapif</span>(v, v.<span class="built_in">size</span>(), i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 排序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line"><span class="built_in">swap</span>(v[i], v[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">heapif</span>(v, i, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">10</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">8</span>&#125;;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;排序前：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; i : v) &#123;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">// ----------------------------------------------------</span></span><br><span class="line"><span class="built_in">heap_sort</span>(v, v.<span class="built_in">size</span>());</span><br><span class="line"><span class="comment">// ----------------------------------------------------</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;排序后：&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; i : v) &#123;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2024/02/28/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/sort.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="排序算法" scheme="http://example.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>标准模板库STL</title>
    <link href="http://example.com/2024/02/26/%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93STL/"/>
    <id>http://example.com/2024/02/26/%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93STL/</id>
    <published>2024-02-26T12:26:50.000Z</published>
    <updated>2024-04-21T06:32:41.495Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2024/02/26/%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93STL/STL.png"></p><span id="more"></span><h1 id="一、各种容器的特点和适用情况"><a href="#一、各种容器的特点和适用情况" class="headerlink" title="一、各种容器的特点和适用情况"></a>一、各种容器的特点和适用情况</h1><h2 id="1-vector：【可变大小的数组】"><a href="#1-vector：【可变大小的数组】" class="headerlink" title="1.vector：【可变大小的数组】"></a>1.vector：【可变大小的数组】</h2><pre><code>支持快速随机访问。在尾部之外的位置插入/删除元素可能很慢。</code></pre><h2 id="2-array：【固定大小的数组】"><a href="#2-array：【固定大小的数组】" class="headerlink" title="2.array：【固定大小的数组】"></a>2.array：【固定大小的数组】</h2><pre><code>支持快速随机访问。不能添加或删除元素。</code></pre><h2 id="3-forward-list：【单向链表】"><a href="#3-forward-list：【单向链表】" class="headerlink" title="3.forward_list：【单向链表】"></a>3.forward_list：【单向链表】</h2><pre><code>只支持单向顺序访问。任何位置插入/删除元素都很快。</code></pre><h2 id="4-list：【双向链表】"><a href="#4-list：【双向链表】" class="headerlink" title="4.list：【双向链表】"></a>4.list：【双向链表】</h2><pre><code>只支持双向顺序访问。在list任何位置插入/删除元素都很快。</code></pre><h2 id="5-deque：【双端队列】"><a href="#5-deque：【双端队列】" class="headerlink" title="5.deque：【双端队列】"></a>5.deque：【双端队列】</h2><pre><code>支持快速随机访问。在头尾位置插入/删除很快。</code></pre><h2 id="6-string：【可变大小的字符数组】"><a href="#6-string：【可变大小的字符数组】" class="headerlink" title="6.string：【可变大小的字符数组】"></a>6.string：【可变大小的字符数组】</h2><pre><code>支持快速随机访问。在尾部插入/删除元素很快。</code></pre><h3 id="支持随机访问的容器：vector、deque、array、string"><a href="#支持随机访问的容器：vector、deque、array、string" class="headerlink" title="支持随机访问的容器：vector、deque、array、string"></a>支持随机访问的容器：vector、deque、array、string</h3><h3 id="支持在任意位置插入-删除元素：list、forward-list"><a href="#支持在任意位置插入-删除元素：list、forward-list" class="headerlink" title="支持在任意位置插入&#x2F;删除元素：list、forward_list"></a>支持在任意位置插入&#x2F;删除元素：list、forward_list</h3><h3 id="只在尾部插入元素：vector、deque-头部也可以-、string"><a href="#只在尾部插入元素：vector、deque-头部也可以-、string" class="headerlink" title="只在尾部插入元素：vector、deque(头部也可以)、string"></a>只在尾部插入元素：vector、deque(头部也可以)、string</h3><h1 id="二、各种容器的底层机制和常见问题"><a href="#二、各种容器的底层机制和常见问题" class="headerlink" title="二、各种容器的底层机制和常见问题"></a>二、各种容器的底层机制和常见问题</h1><h2 id="1、vector"><a href="#1、vector" class="headerlink" title="1、vector"></a>1、vector</h2><h3 id="（1）底层原理"><a href="#（1）底层原理" class="headerlink" title="（1）底层原理"></a>（1）底层原理</h3><p><font color="#0099ff" size="4" face="黑体">vector底层是一个动态数组。</font></p><pre><code>【vector内存增长机制】     当空间不够时，会自动申请另一片更大的空间（1.5倍或2倍），然后把原来的数据拷贝到新的内存空间，    接着释放原来的内存空间。注意：对vector的任何操作，一旦【引起空间的重新配置】，指向原vector的所有迭代器都将失效。</code></pre><h3 id="（2）常见问题"><a href="#（2）常见问题" class="headerlink" title="（2）常见问题"></a>（2）常见问题</h3><pre><code>【问】vector中size和capacity的区别？【答】size表示当前vector中有多少元素，capacity表示可以容纳多少元素。【问】vector扩容为什么要以1.5倍或者2倍扩容？【答】考虑可能产生堆空间浪费，成倍增长倍数不能太大，最好的倍增长因子在（1，2）之间，通常为1.5或者2。【问】vector迭代器失效的情况？【答】当插入一个元素到vector中，由于引起了内存重新分配，因此指向原内存的迭代器全部失效；    当删除容器中的一个元素后，若迭代器指向该被删除元素，那么迭代器失效。【问】vector的元素类型可以是引用吗？【答】不能！vector的底层实现要求是连续的对象排列，    引用并非对象，没有实际地址，因此vector的元素类型不能是引用。</code></pre><p><font color="red" size="5" face="黑体">vector内存释放：vector<int>().swap(vec);</int></font></p><h2 id="2、list"><a href="#2、list" class="headerlink" title="2、list"></a>2、list</h2><h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><p><font color="#0099ff" size="4" face="黑体">list底层是一个双向链表。</font></p><pre><code>以节点为单位存储数据，节点地址在内存中不一定连续，每次插入/删除一个元素，就配置或释放一个元素空间。</code></pre><h2 id="3、deque"><a href="#3、deque" class="headerlink" title="3、deque"></a>3、deque</h2><h3 id="（1）底层原理-1"><a href="#（1）底层原理-1" class="headerlink" title="（1）底层原理"></a>（1）底层原理</h3><p><font color="#0099ff" size="4" face="黑体">deque底层是一个双端开口的连续空间（双端队列）。</font></p><h3 id="（2）常见问题-1"><a href="#（2）常见问题-1" class="headerlink" title="（2）常见问题"></a>（2）常见问题</h3><pre><code>【问】什么情况下使用deque？【答】需要从首尾两端进行插入删除操作的时候选择deque。</code></pre><h2 id="4、priority-queue"><a href="#4、priority-queue" class="headerlink" title="4、priority_queue"></a>4、priority_queue</h2><h3 id="底层原理-1"><a href="#底层原理-1" class="headerlink" title="底层原理"></a>底层原理</h3><p><font color="#0099ff" size="4" face="黑体">优先队列，底层是用堆来实现的。</font></p><pre><code>在优先队列中，队首元素一定是当前队列中优先级最高的那一个。</code></pre><h2 id="5、map、multimap、set、multiset"><a href="#5、map、multimap、set、multiset" class="headerlink" title="5、map、multimap、set、multiset"></a>5、map、multimap、set、multiset</h2><h3 id="（1）底层原理-2"><a href="#（1）底层原理-2" class="headerlink" title="（1）底层原理"></a>（1）底层原理</h3><p><font color="#0099ff" size="4" face="黑体">红黑树。</font></p><pre><code>【红黑树特性】   1.每个结点或是红色或是黑色                2.根节点是黑的                3.每个叶子结点是黑的                4.如果一个结点是红的，则它的两个儿子均是黑的                5.每个结点到其子孙结点的所有路径上包含相同数目的黑色结点【各自特点】1.set和multiset会自动将元素排序，    set中元素不允许重复，multiset允许重复。2.map和multimap将（key，value）组成的pair键值对作为元素，根据key的排序准则自动将元素排序，    map中key不允许重复，multimap允许重复。注意：map、set的增删改查速度都为logn，是比较高效的</code></pre><h3 id="（2）常见问题-2"><a href="#（2）常见问题-2" class="headerlink" title="（2）常见问题"></a>（2）常见问题</h3><pre><code>【问】为什么map、set的插入删除效率比其他序列容器高，而且每次插入后，以前保存的迭代器不会失效？【答】    1.因为存储的是结点，不需要内存拷贝和内存移动。    2.因为插入操作只是结点指针换来换去，结点内存没有改变，内存不变，指向内存的迭代器也不会变。</code></pre><h2 id="6、unordered-map、unordered-set"><a href="#6、unordered-map、unordered-set" class="headerlink" title="6、unordered_map、unordered_set"></a>6、unordered_map、unordered_set</h2><h3 id="（1）底层原理-3"><a href="#（1）底层原理-3" class="headerlink" title="（1）底层原理"></a>（1）底层原理</h3><p><font color="#0099ff" size="4" face="黑体">哈希表。</font></p><pre><code>【哈希表特点】 数据存储和查找的时间大大降低，时间复杂度为O(1)，代价是消耗比较多的内存。</code></pre><h3 id="（2）常见问题-3"><a href="#（2）常见问题-3" class="headerlink" title="（2）常见问题"></a>（2）常见问题</h3><pre><code>【问】unordered_map与map的区别？【答】    1.unordered_map需要hash函数，而map只需要比较函数即可。    2.unordered_map底层存储结构是哈希表存储，而map底层存储结构是红黑树。    3.unordered_map查找速度为常数级，而map为log（n）级</code></pre><h1 id="三、迭代器种类和失效问题"><a href="#三、迭代器种类和失效问题" class="headerlink" title="三、迭代器种类和失效问题"></a>三、迭代器种类和失效问题</h1><h2 id="1、迭代器种类"><a href="#1、迭代器种类" class="headerlink" title="1、迭代器种类"></a>1、迭代器种类</h2><pre><code>输入迭代器、输出迭代器、前向迭代器、双向迭代器、随机访问迭代器</code></pre><h2 id="2、迭代器失效问题"><a href="#2、迭代器失效问题" class="headerlink" title="2、迭代器失效问题"></a>2、迭代器失效问题</h2><h3 id="（1）插入操作"><a href="#（1）插入操作" class="headerlink" title="（1）插入操作"></a>（1）插入操作</h3><pre><code>【list、forward_list】    插入操作不会导致迭代器失效。【vector、string】    如果导致内存重新分配，失效。如果内存没有重新分配，那么插入点之前的迭代器有效，插入点之后的失效。【deque】    如果插入点不是首尾位置，失效。</code></pre><h3 id="（2）删除操作"><a href="#（2）删除操作" class="headerlink" title="（2）删除操作"></a>（2）删除操作</h3><pre><code>【list、forward_list】    删除操作不会导致迭代器失效。【vector、string】    删除点之前的有效。【deque】    删除点不是首尾位置，失效。【关联容器map】    如果一个元素被删除，那么其对应的迭代器就失效了。</code></pre><h1 id="四、STL容器的线程安全性"><a href="#四、STL容器的线程安全性" class="headerlink" title="四、STL容器的线程安全性"></a>四、STL容器的线程安全性</h1><h2 id="1-线程安全的情况"><a href="#1-线程安全的情况" class="headerlink" title="1.线程安全的情况"></a>1.线程安全的情况</h2><pre><code>1.多线程读取[同一容器]。2.多线程同时写[不同容器]</code></pre><h2 id="2-线程不安全的情况"><a href="#2-线程不安全的情况" class="headerlink" title="2.线程不安全的情况"></a>2.线程不安全的情况</h2><pre><code>1.同一容器进行多线程读写2.每次调用容器成员函数都要锁定该容器3.在每个容器返回的迭代器生存期之内要锁定该容器4.在每个容器调用算法执行期间锁定该容器</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2024/02/26/%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93STL/STL.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="STL" scheme="http://example.com/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>C++11常用特性</title>
    <link href="http://example.com/2024/02/26/C-11%E5%B8%B8%E7%94%A8%E7%89%B9%E6%80%A7/"/>
    <id>http://example.com/2024/02/26/C-11%E5%B8%B8%E7%94%A8%E7%89%B9%E6%80%A7/</id>
    <published>2024-02-26T12:11:13.000Z</published>
    <updated>2024-03-11T13:17:52.365Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2024/02/26/C-11%E5%B8%B8%E7%94%A8%E7%89%B9%E6%80%A7/C++11.jpg"></p><span id="more"></span><h1 id="一、稳定性和兼容性"><a href="#一、稳定性和兼容性" class="headerlink" title="一、稳定性和兼容性"></a>一、稳定性和兼容性</h1><h2 id="1、字符串原始字面量"><a href="#1、字符串原始字面量" class="headerlink" title="1、字符串原始字面量"></a>1、字符串原始字面量</h2><p><font color="#0099ff" size="4" face="黑体">【语法格式】 R”(字符串)”</font></p><pre><code>比如打印路径问题：</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">R&quot;(D:\hello\world\test.txt)&quot;</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">输出结果：D:\hello\world\test.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2、超长整形long-long"><a href="#2、超长整形long-long" class="headerlink" title="2、超长整形long long"></a>2、超长整形long long</h2><pre><code>至少有64位</code></pre><h2 id="3、类成员的快速初始化"><a href="#3、类成员的快速初始化" class="headerlink" title="3、类成员的快速初始化"></a>3、类成员的快速初始化</h2><h3 id="（1）初始化类的非静态成员"><a href="#（1）初始化类的非静态成员" class="headerlink" title="（1）初始化类的非静态成员"></a>（1）初始化类的非静态成员</h3><p><font color="orange" size="4" face="黑体">【不仅可以使用“&#x3D;”，也可以使用“{}”】</font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">9</span>;      <span class="comment">//等号</span></span><br><span class="line"><span class="type">int</span> b = &#123;<span class="number">5</span>&#125;;    <span class="comment">//花括号</span></span><br><span class="line"><span class="type">int</span> c&#123;<span class="number">12</span>&#125;;      <span class="comment">//花括号（可以省略等号！）</span></span><br><span class="line"><span class="type">double</span> array[<span class="number">4</span>] = &#123; <span class="number">3.14</span>, <span class="number">3.15</span>, <span class="number">3.16</span>, <span class="number">3.17</span>&#125;;</span><br><span class="line"><span class="type">double</span> array1[<span class="number">4</span>] &#123; <span class="number">3.14</span>, <span class="number">3.15</span>, <span class="number">3.16</span>, <span class="number">3.17</span> &#125;; <span class="comment">//花括号（可以省略等号！）</span></span><br><span class="line"><span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;     <span class="comment">// 不能用()初始化！</span></span><br><span class="line">string s2&#123; <span class="string">&quot;hello, world&quot;</span> &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="（2）类内部赋值和初始化列表"><a href="#（2）类内部赋值和初始化列表" class="headerlink" title="（2）类内部赋值和初始化列表"></a>（2）类内部赋值和初始化列表</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Init</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Init</span>(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z) :<span class="built_in">a</span>(x), <span class="built_in">b</span>(y), <span class="built_in">c</span>(z) &#123;&#125; <span class="comment">//初始化列表：用x初始化a，用y初始化b，用z初始化c</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;      <span class="comment">//就地初始化</span></span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>;      <span class="comment">//就地初始化</span></span><br><span class="line">    <span class="type">int</span> c = <span class="number">3</span>;      <span class="comment">//就地初始化</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Init <span class="title">tmp</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span></span>;   <span class="comment">//覆盖【就地初始化的值】</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; tmp.a &lt;&lt; <span class="string">&quot;, b: &quot;</span> &lt;&lt; tmp.b &lt;&lt; <span class="string">&quot;, c: &quot;</span> &lt;&lt; tmp.c &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    输出：a:<span class="number">10</span>,b:<span class="number">20</span>,c:<span class="number">30</span></span><br></pre></td></tr></table></figure><h2 id="4、final-和-override"><a href="#4、final-和-override" class="headerlink" title="4、final 和 override"></a>4、final 和 override</h2><h3 id="（1）final"><a href="#（1）final" class="headerlink" title="（1）final"></a>（1）final</h3><p><font color="orange" size="4" face="黑体">【限制某个类不能被继承，或者某个虚函数不能被重写】<br>【如果final修饰函数，则只能修饰虚函数，且final关键字要放到函数或者类的后面】</font></p><p><font color="red" size="4" face="黑体">【修饰函数】：只能修饰虚函数，这样就能阻止子类继承父类的这个函数</font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//【父类】</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base class...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//【子类】</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">final</span>   <span class="comment">//不希望孙子类继续重写这个函数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Child class...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//【孙子类】</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandChild</span> : <span class="keyword">public</span> Child</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 语法错误, 不允许重写</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;GrandChild class...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*test()是基类中的一个虚函数，在子类中重写了这个方法，但是不希望孙子类中继续重写这个</span></span><br><span class="line"><span class="comment">方法了，因此在子类中将test()方法标记为final，孙子类中对这个方法就只有使用的份了。*/</span></span><br></pre></td></tr></table></figure><p><font color="red" size="4" face="黑体">【修饰类】：使用final修饰过的类不允许被继承，即该类不能有派生类</font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//【父类】</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base class...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//【子类：有final修饰了！】</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">final</span>: <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Child class...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//【孙子类】</span></span><br><span class="line"><span class="comment">// error, 语法错误</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandChild</span> : <span class="keyword">public</span> Child</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*子类有final关键字修饰，因此孙子类继承子类是非法的*/</span></span><br></pre></td></tr></table></figure><h3 id="（2）override"><a href="#（2）override" class="headerlink" title="（2）override"></a>（2）override</h3><p><font color="red" size="4" face="黑体">【指名道姓要重写基类的虚函数】</font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//【父类】</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base class...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//【子类】</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//override：子类要重写基类的虚函数test（）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">override</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Child class...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//【孙子类】</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandChild</span> : <span class="keyword">public</span> Child</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//override：孙子类要重写基类中的虚函数test</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Child class...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5、模板的优化"><a href="#5、模板的优化" class="headerlink" title="5、模板的优化"></a>5、模板的优化</h2><h3 id="默认模板参数"><a href="#默认模板参数" class="headerlink" title="默认模板参数"></a>默认模板参数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数模板定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T = <span class="type">long</span>, <span class="keyword">typename</span> U = <span class="type">char</span>&gt; <span class="comment">//默认模板类型&lt;long, char&gt;</span></span><br><span class="line"><span class="type">void</span> <span class="built_in">func</span>(T arg1 = <span class="number">100</span>, U arg2 = <span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;arg1: &quot;</span> &lt;&lt; arg1 &lt;&lt; <span class="string">&quot;, arg2: &quot;</span> &lt;&lt; arg2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="red" size="4" face="黑体">【优先级】：从高到低</font></p><p><font color="green" size="4" face="黑体">T0:显示给出。 func(int, int);           —-&gt; &lt;int, int&gt;<br>    T1:根据实参自动推导类型。 func(int, 10); —-&gt; &lt;int, int&gt;<br>    T2:使用默认模板参数。 func(a,b);         —-&gt; &lt;long, char&gt;<br>    T4:没有指定默认模板类型，并且没有实参可用来自动推导。 func();    —-&gt;报错</font></p><h2 id="6、数值类型和字符串之间的转换"><a href="#6、数值类型和字符串之间的转换" class="headerlink" title="6、数值类型和字符串之间的转换"></a>6、数值类型和字符串之间的转换</h2><h3 id="（1）数值转换为字符串"><a href="#（1）数值转换为字符串" class="headerlink" title="（1）数值转换为字符串"></a>（1）数值转换为字符串</h3><p><font color="#0099ff" size="4" face="黑体">to_string(val)</font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">to_string</span>(<span class="number">3.14</span>);  <span class="comment">//&quot;3.14&quot;</span></span><br><span class="line"><span class="built_in">to_string</span>(<span class="number">5.20</span> + <span class="number">3.14</span>);  <span class="comment">//&quot;5.20 + 3.14&quot;</span></span><br></pre></td></tr></table></figure><h3 id="（2）字符串转换为数值"><a href="#（2）字符串转换为数值" class="headerlink" title="（2）字符串转换为数值"></a>（2）字符串转换为数值</h3><p><font color="#0099ff" size="4" face="黑体">stoi(str)</font><br><font color="#0099ff" size="4" face="黑体">stof(str)</font><br><font color="#0099ff" size="4" face="黑体">stod(str)</font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">string str1 = <span class="string">&quot;45&quot;</span>;</span><br><span class="line">string str2 = <span class="string">&quot;3.14159&quot;</span>;</span><br><span class="line">string str3 = <span class="string">&quot;9527 with words&quot;</span>;</span><br><span class="line">string str4 = <span class="string">&quot;words and 2&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> int_1 = <span class="built_in">stoi</span>(str1);         <span class="comment">//int_1 = 45</span></span><br><span class="line"><span class="type">float</span> float_1 = <span class="built_in">stof</span>(str2);     <span class="comment">//float_1 = 3.14159</span></span><br><span class="line"><span class="type">double</span> double_1 = <span class="built_in">stod</span>(str3);   <span class="comment">//double_1 = 9527.0</span></span><br><span class="line"><span class="type">int</span> int_2 = <span class="built_in">stoi</span>(str4);         <span class="comment">//错误！如果字符串第一个字符不是数值，则转换失败！</span></span><br></pre></td></tr></table></figure><h2 id="7、静态断言-static-assert"><a href="#7、静态断言-static-assert" class="headerlink" title="7、静态断言 static_assert"></a>7、静态断言 static_assert</h2><h3 id="（1）断言-assert"><a href="#（1）断言-assert" class="headerlink" title="（1）断言 assert"></a>（1）断言 assert</h3><p><font color="#0099ff" size="4" face="黑体">运行时断言</font><br><font color="#0099ff" size="4" face="黑体">assert(expression);</font></p><pre><code>【断言能够帮助开发者快速定位出错地方，并且防止程序继续执行带来混乱】</code></pre><h3 id="（2）静态断言-static-assert"><a href="#（2）静态断言-static-assert" class="headerlink" title="（2）静态断言 static_assert"></a>（2）静态断言 static_assert</h3><p><font color="#0099ff" size="4" face="黑体">编译时断言</font><br><font color="#0099ff" size="4" face="黑体">static_assert(expression, 断言提示);</font></p><pre><code>【不需要引入头文件，且可以添加断言提示信息】</code></pre><h2 id="8、noexcept"><a href="#8、noexcept" class="headerlink" title="8、noexcept"></a>8、noexcept</h2><p><font color="#0099ff" size="4" face="黑体">被其修饰的函数不会抛出异常！</font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="type">double</span> <span class="title">divisionMethod</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;division by zero!!!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="#0099aa" size="7" face="黑体">———————————————————************************************—————————————————————————–</font></p><h1 id="二、易学性和易用性"><a href="#二、易学性和易用性" class="headerlink" title="二、易学性和易用性"></a>二、易学性和易用性</h1><h2 id="1、自动类型推导"><a href="#1、自动类型推导" class="headerlink" title="1、自动类型推导"></a>1、自动类型推导</h2><h3 id="（1-1）auto"><a href="#（1-1）auto" class="headerlink" title="（1.1）auto"></a>（1.1）auto</h3><p><font color="#0099ff" size="4" face="黑体">【语法格式】 aoto 变量名 &#x3D; 变量值</font></p><pre><code>即根据变量值推导变量的类型，所以必须给一个变量值初始化。</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">3.14</span>;      <span class="comment">// x 是浮点型 double</span></span><br><span class="line"><span class="keyword">auto</span> y = <span class="number">520</span>;       <span class="comment">// y 是整形 int</span></span><br><span class="line"><span class="keyword">auto</span> z = <span class="string">&#x27;a&#x27;</span>;       <span class="comment">// z 是字符型 char</span></span><br><span class="line"><span class="keyword">auto</span> nb;            <span class="comment">// error，变量必须要初始化</span></span><br><span class="line"><span class="keyword">auto</span> <span class="type">double</span> nbl;    <span class="comment">// 语法错误, 不能修改数据类型   </span></span><br></pre></td></tr></table></figure><pre><code>【有const、volatile限定符的情况下】</code></pre><p><font color="#0066kk" size="4" face="楷体">当变量<font color="red" size="4" face="楷体">不是指针或者引用</font>类型时，推导的结果中<font color="red" size="4" face="楷体">不会保留</font>const、volatile关键字</font><br><font color="#0066kk" size="4" face="楷体">当变量<font color="red" size="4" face="楷体">是指针或者引用</font>类型时，推导的结果中<font color="red" size="4" face="楷体">保留</font>const、volatile关键字</font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> tmp = <span class="number">250</span>;          </span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> a1 = tmp;    <span class="comment">//auto:int</span></span><br><span class="line"><span class="keyword">auto</span> a2 = a1;           <span class="comment">//auto:int(不保留const)</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> &amp;a3 = tmp;   <span class="comment">//auto:int</span></span><br><span class="line"><span class="keyword">auto</span> &amp;a4 = a3;          <span class="comment">//auto:const int(保留const)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//变量a1的数据类型为 const int，因此auto关键字被推导为 int类型</span></span><br><span class="line"><span class="comment">//变量a2的数据类型为 int，但是a2没有声明为指针或引用因此 const属性被去掉, auto被推导为 int</span></span><br><span class="line"><span class="comment">//变量a3的数据类型为 const int&amp;，a3被声明为引用因此 const属性被保留，auto关键字被推导为 int类型</span></span><br><span class="line"><span class="comment">//变量a4的数据类型为 const int&amp;，a4被声明为引用因此 const属性被保留，auto关键字被推导为 const int类型</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="（1-2）auto的限制"><a href="#（1-2）auto的限制" class="headerlink" title="（1.2）auto的限制"></a>（1.2）auto的限制</h3><p><font color="#0099gg" size="4" face="黑体">1、不能作为函数参数使用</font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="keyword">auto</span> a, <span class="keyword">auto</span> b)</span><span class="comment">// 错误！</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt;<span class="string">&quot;, b: &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="#0099gg" size="4" face="黑体">2、不能用于类的非静态成员变量的初始化</font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> v1 = <span class="number">0</span>;                    <span class="comment">// 错误！</span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">auto</span> v2 = <span class="number">0</span>;             <span class="comment">// 错误！类的静态非常量成员不允许在类内部直接初始化</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="keyword">auto</span> v3 = <span class="number">10</span>;      <span class="comment">// ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="#0099gg" size="4" face="黑体">3、不能使用auto关键字定义数组</font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> array[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;  <span class="comment">// 定义数组</span></span><br><span class="line">    <span class="keyword">auto</span> t1 = array;            <span class="comment">// ok, t1被推导为 int* 类型</span></span><br><span class="line">    <span class="keyword">auto</span> t2[] = array;          <span class="comment">// error, auto无法定义数组</span></span><br><span class="line">    <span class="keyword">auto</span> t3[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;;   <span class="comment">// error, auto无法定义数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="#0099gg" size="4" face="黑体">4、无法使用auto推导出模板参数</font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test&lt;<span class="type">double</span>&gt; t;</span><br><span class="line">    Test&lt;<span class="keyword">auto</span>&gt; t1 = t;           <span class="comment">// error, 无法推导出模板类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（1-3）auto的应用"><a href="#（1-3）auto的应用" class="headerlink" title="（1.3）auto的应用"></a>（1.3）auto的应用</h3><p><font color="#0099gg" size="4" face="黑体">1、用于STL容器的遍历</font></p><p>【旧版本遍历容器】</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map&lt;<span class="type">int</span>, string&gt; person;</span><br><span class="line">    map&lt;<span class="type">int</span>, string&gt;::iterator it = person.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span> (; it != person.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【auto遍历容器】</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map&lt;<span class="type">int</span>, string&gt; person;</span><br><span class="line">    <span class="comment">//遍历person</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = person.<span class="built_in">begin</span>(); it != person.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="#0099gg" size="4" face="黑体">2、用于泛型编程</font></p><h3 id="（2-1）decltype"><a href="#（2-1）decltype" class="headerlink" title="（2.1）decltype"></a>（2.1）decltype</h3><p><font color="#0099ff" size="4" face="黑体">【语法格式】 decltype(表达式)</font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">decltype</span>(a) b = <span class="number">99</span>;                 <span class="comment">// b -&gt; int</span></span><br><span class="line"><span class="keyword">decltype</span>(a+<span class="number">3.14</span>) c = <span class="number">52.13</span>;         <span class="comment">// c -&gt; double</span></span><br><span class="line"><span class="keyword">decltype</span>(a+b*c) d = <span class="number">520.1314</span>;       <span class="comment">// d -&gt; double</span></span><br></pre></td></tr></table></figure><h3 id="（2-2）推导规则"><a href="#（2-2）推导规则" class="headerlink" title="（2.2）推导规则"></a>（2.2）推导规则</h3><p>【表达式为<font color="red" size="4" face="黑体">普通变量或者普通表达式或者类表达式</font>，在这种情况下，使用decltype推导出的类型和<font color="red" size="4" face="黑体">表达式的类型</font>是一致的】</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string text;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">110</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">99</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> &amp;y = x;</span><br><span class="line">    <span class="keyword">decltype</span>(x) a = x;</span><br><span class="line">    <span class="keyword">decltype</span>(y) b = x;</span><br><span class="line">    <span class="keyword">decltype</span>(Test::value) c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Test t;</span><br><span class="line">    <span class="keyword">decltype</span>(t.text) d = <span class="string">&quot;hello, world&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">    变量a被推导为 int类型</span></span><br><span class="line"><span class="comment">    变量b被推导为 const int &amp;类型</span></span><br><span class="line"><span class="comment">    变量c被推导为 const int类型</span></span><br><span class="line"><span class="comment">    变量d被推导为 string类型</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>【表达式是<font color="red" size="4" face="黑体">函数调用</font>，使用decltype推导出的类型和<font color="red" size="4" face="黑体">函数返回值</font>一致】</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;...&#125;;</span><br><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func_int</span><span class="params">()</span></span>;                 <span class="comment">// 返回值为 int</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">func_int_r</span><span class="params">()</span></span>;              <span class="comment">// 返回值为 int&amp;</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp;&amp; <span class="title">func_int_rr</span><span class="params">()</span></span>;            <span class="comment">// 返回值为 int&amp;&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">func_cint</span><span class="params">()</span></span>;          <span class="comment">// 返回值为 const int</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>&amp; <span class="title">func_cint_r</span><span class="params">()</span></span>;       <span class="comment">// 返回值为 const int&amp;</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>&amp;&amp; <span class="title">func_cint_rr</span><span class="params">()</span></span>;     <span class="comment">// 返回值为 const int&amp;&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> Test <span class="title">func_ctest</span><span class="params">()</span></span>;        <span class="comment">// 返回值为 const Test</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//decltype类型推导</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_int</span>()) a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_int_r</span>()) b = n;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_int_rr</span>()) c = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_cint</span>())  d = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_cint_r</span>())  e = n;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_cint_rr</span>()) f = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_ctest</span>()) g = <span class="built_in">Test</span>();</span><br></pre></td></tr></table></figure><p><font color="green" size="4" face="黑体">变量a被推导为 int类型<br>变量b被推导为 int&amp;类型<br>变量c被推导为 int&amp;&amp;类型<font color="red" size="4" face="黑体"><br>变量d被推导为 int类型</font><br>变量e被推导为 const int &amp;类型<br>变量f被推导为 const int &amp;&amp;类型<br>变量g被推导为 const Test类型</font></p><p><font color="orange" size="4" face="黑体">函数 func_cint() 返回的是一个<font color="red" size="4" face="黑体">纯右值</font>（在表达式执行结束后不再存在的数据，也就是临时性的数据），对于纯右值而言，只有<font color="red" size="4" face="黑体">类类型</font>可以携带const、volatile限定符，除此之外需要忽略掉这两个限定符，因此推导出的变量d的类型为 int 而不是 const int。</font></p><p>【表达式是<font color="red" size="4" face="黑体">一个左值，或者被括号( )包围</font>，使用decltype推导出的类型是<font color="red" size="4" face="黑体">表达式类型的引用</font>（如果有const、volatile限定符不能忽略）。】</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> Test obj;</span><br><span class="line">    <span class="comment">//带有括号的表达式</span></span><br><span class="line">    <span class="keyword">decltype</span>(obj.num) a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">decltype</span>((obj.num)) b = a;</span><br><span class="line">    <span class="comment">//加法表达式</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>, m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">decltype</span>(n + m) c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">decltype</span>(n = n + m) d = n;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="green" size="4" face="黑体">obj.num 为类的成员访问表达式，符合场景1，因此 a 的类型为int<br>obj.num 带有括号，符合场景3，因此b 的类型为 const int&amp;。<br>n+m 得到一个右值，符合场景1，因此c的类型为 int<br>n&#x3D;n+m 得到一个左值 n，符合场景3，因此d的类型为 int&amp;</font></p><h3 id="（3）返回类型后置"><a href="#（3）返回类型后置" class="headerlink" title="（3）返回类型后置"></a>（3）返回类型后置</h3><p><font color="#0099ff" size="4" face="黑体">【语法格式】 aoto func(参数1, 参数2, …) -&gt; decltype(参数表达式)</font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="comment">// 返回类型后置语法</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T t, U u)</span> -&gt; <span class="title">decltype</span><span class="params">(t+u)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、基于范围的for循环"><a href="#2、基于范围的for循环" class="headerlink" title="2、基于范围的for循环"></a>2、基于范围的for循环</h2><p><font color="#0099ff" size="4" face="黑体">【语法格式】<br> for (变量 : 容器) {<br>    &#x2F;&#x2F; 循环体<br>}</font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; t&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> value : t)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="orange" size="4" face="黑体">如果需要在遍历过程中<font color="red" size="4" face="黑体">修改元素的值</font>，需要<font color="red" size="4" face="黑体">使用引用</font>。</font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; t&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;遍历修改之前的容器: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;value : t)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; value++ &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;遍历修改之后的容器: &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;value : t)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><font color="green" size="4" face="黑体">遍历修改之前的容器: 1 2 3 4 5 6<br>遍历修改之后的容器: 2 3 4 5 6 7</font></p><p><font color="orange" size="4" face="黑体">如果<font color="red" size="4" face="黑体">只读</font>容器数据，可以使用<font color="red" size="4" face="黑体">const auto&amp;</font>，效率更高</font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; t&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; value : t)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="red" size="5" face="黑体">使用细节</font></p><p><font color="orange" size="4" face="黑体">细节一、关系型容器，map</font></p><p><font color="green" size="4" face="黑体">使用普通的for循环方式遍历关联性容器，<font color="red" size="4" face="黑体">it-&gt;first<br>it-&gt;second</font></font><br><font color="green" size="4" face="黑体">使用基于范围的for循环方式遍历关联性容器，<font color="red" size="4" face="黑体">it.first<br>it.second</font></font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map&lt;<span class="type">int</span>, string&gt; m&#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="string">&quot;lucy&quot;</span>&#125;,&#123;<span class="number">2</span>, <span class="string">&quot;lily&quot;</span>&#125;,&#123;<span class="number">3</span>, <span class="string">&quot;tom&quot;</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基于范围的for循环方式</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it : m)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;id: &quot;</span> &lt;&lt; it.first &lt;&lt; <span class="string">&quot;, name: &quot;</span> &lt;&lt; it.second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通的for循环方式</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;id: &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;, name: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="orange" size="4" face="黑体">细节二、元素只读</font></p><p><font color="green" size="4" face="黑体">对应<font color="red" size="4" face="黑体">set容器</font>来说，内部<font color="red" size="4" face="黑体">元素都是只读的</font>，这是由容器的特性决定的，因此在for循环中<font color="red" size="4" face="黑体">auto&amp;会被视为const auto &amp; </font></font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; st&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;item : st) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; item++ &lt;&lt; endl;<span class="comment">// error, 不能给常量赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="green" size="4" face="黑体">遍历<font color="red" size="4" face="黑体">关系型容器</font>时，对<font color="red" size="4" face="黑体">key值</font>也不能修改</font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map&lt;<span class="type">int</span>, string&gt; m&#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="string">&quot;lucy&quot;</span>&#125;,&#123;<span class="number">2</span>, <span class="string">&quot;lily&quot;</span>&#125;,&#123;<span class="number">3</span>, <span class="string">&quot;tom&quot;</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; item : m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// item.first 是一个常量</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;id: &quot;</span> &lt;&lt; item.first++ &lt;&lt; <span class="string">&quot;, name: &quot;</span> &lt;&lt; item.second &lt;&lt; endl;  <span class="comment">// error</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="orange" size="4" face="黑体">细节三、访问次数</font></p><p><font color="green" size="4" face="黑体">对应<font color="red" size="4" face="黑体">基于范围的for循环</font>来说，冒号后边的表达式<font color="red" size="4" face="黑体">只会被执行一次</font>。在得到遍历对象之后会先确定好迭代的范围，基于这个范围直接进行遍历。如果是普通的for循环，在每次迭代的时候都需要判断是否已经到了结束边界。</font></p><h2 id="3、指针空值类型-nullptr"><a href="#3、指针空值类型-nullptr" class="headerlink" title="3、指针空值类型-nullptr"></a>3、指针空值类型-nullptr</h2><p><font color="orange" size="4" face="黑体">【作用】 <font color="red" size="4" face="黑体">初始化空指针</font></font><br><font color="orange" size="4" face="黑体">【好处】 <font color="red" size="4" face="黑体">能自动匹配指针类型。</font></font></p><h2 id="4、lambda表达式"><a href="#4、lambda表达式" class="headerlink" title="4、lambda表达式"></a>4、lambda表达式</h2><h3 id="（1）基本语法"><a href="#（1）基本语法" class="headerlink" title="（1）基本语法"></a>（1）基本语法</h3><p><font color="#0099ff" size="5" face="黑体">【语法格式】   [capture] (params) opt -&gt; ret {body;};</font></p><p><font color="green" size="3" face="黑体"> 其中opt常有：<br>mutable：可以修改按值传递进来的拷贝<font color="orange" size="3" face="楷体">（注意是能修改拷贝，而不是值本身）</font><br>exception：指定函数抛出的异常，如抛出整数类型的异常，可以使用throw();</font></p><h3 id="（2）捕获列表"><a href="#（2）捕获列表" class="headerlink" title="（2）捕获列表"></a>（2）捕获列表</h3><p><font color="green" size="3" face="楷体">[] - 不捕捉任何变量<br>[&amp;] - 捕获外部作用域中所有变量, 并作为引用在函数体内使用 (按引用捕获)<br>[&#x3D;] - 捕获外部作用域中所有变量, 并作为副本在函数体内使用 (按值捕获)<font color="orange" size="3" face="楷体"><br>拷贝的副本在匿名函数体内部是只读的</font><br>[&#x3D;, &amp;foo] - 按值捕获外部作用域中所有变量, 并按照引用捕获外部变量 foo<br>[bar] - 按值捕获 bar 变量, 同时不捕获其他变量<br>[&amp;bar] - 按引用捕获 bar 变量, 同时不捕获其他变量<br>[this] - 捕获当前类中的this指针</font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> x1 = [] &#123;<span class="keyword">return</span> m_number; &#125;;                      <span class="comment">// error</span></span><br><span class="line">        <span class="keyword">auto</span> x2 = [=] &#123;<span class="keyword">return</span> m_number + x + y; &#125;;             <span class="comment">// ok</span></span><br><span class="line">        <span class="keyword">auto</span> x3 = [&amp;] &#123;<span class="keyword">return</span> m_number + x + y; &#125;;             <span class="comment">// ok</span></span><br><span class="line">        <span class="keyword">auto</span> x4 = [<span class="keyword">this</span>] &#123;<span class="keyword">return</span> m_number; &#125;;                  <span class="comment">// ok</span></span><br><span class="line">        <span class="keyword">auto</span> x5 = [<span class="keyword">this</span>] &#123;<span class="keyword">return</span> m_number + x + y; &#125;;          <span class="comment">// error</span></span><br><span class="line">        <span class="keyword">auto</span> x6 = [<span class="keyword">this</span>, x, y] &#123;<span class="keyword">return</span> m_number + x + y; &#125;;    <span class="comment">// ok</span></span><br><span class="line">        <span class="keyword">auto</span> x7 = [<span class="keyword">this</span>] &#123;<span class="keyword">return</span> m_number++; &#125;;                <span class="comment">// ok</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m_number = <span class="number">100</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><font color="green" size="3" face="楷体"> x1：错误，没有捕获外部变量，不能使用类成员 m_number<br>x2：正确，以值拷贝的方式捕获所有外部变量<br>x3：正确，以引用的方式捕获所有外部变量<br>x4：正确，捕获this指针，可访问对象内部成员<br>x5：错误，捕获this指针，可访问类内部成员，没有捕获到变量x，y，因此不能访问。<br>x6：正确，捕获this指针，x，y<br>x7：正确，捕获this指针，并且可以修改对象内部变量的值<br></font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">auto</span> f1 = [] &#123;<span class="keyword">return</span> a; &#125;;                        <span class="comment">// error</span></span><br><span class="line">    <span class="keyword">auto</span> f2 = [&amp;] &#123;<span class="keyword">return</span> a++; &#125;;                     <span class="comment">// ok</span></span><br><span class="line">    <span class="keyword">auto</span> f3 = [=] &#123;<span class="keyword">return</span> a; &#125;;                       <span class="comment">// ok</span></span><br><span class="line">    <span class="keyword">auto</span> f4 = [=] &#123;<span class="keyword">return</span> a++; &#125;;                     <span class="comment">// error</span></span><br><span class="line">    <span class="keyword">auto</span> f5 = [a] &#123;<span class="keyword">return</span> a + b; &#125;;                   <span class="comment">// error</span></span><br><span class="line">    <span class="keyword">auto</span> f6 = [a, &amp;b] &#123;<span class="keyword">return</span> a + (b++); &#125;;           <span class="comment">// ok</span></span><br><span class="line">    <span class="keyword">auto</span> f7 = [=, &amp;b] &#123;<span class="keyword">return</span> a + (b++); &#125;;           <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="green" size="3" face="楷体"> f1：错误，没有捕获外部变量，因此无法访问变量 a<br>f2：正确，使用引用的方式捕获外部变量，可读写<br>f3：正确，使用值拷贝的方式捕获外部变量，可读<br>f4：错误，使用值拷贝的方式捕获外部变量，可读不能写<br>f5：错误，使用拷贝的方式捕获了外部变量a，没有捕获外部变量b，因此无法访问变量b<br>f6：正确，使用拷贝的方式捕获了外部变量a，只读，使用引用的方式捕获外部变量b，可读写<br>f7：正确，使用值拷贝的方式捕获所有外部变量以及b的引用，b可读写，其他只读<br></font></p><p><font color="red" size="5" face="楷体"> 【总结】 按引用捕获的可以在lambda表达式中修改！按值捕获的不可以修改！（如果要修改，可以在opt选项处添加mutable参数） </font></p><h3 id="（3）返回值"><a href="#（3）返回值" class="headerlink" title="（3）返回值"></a>（3）返回值</h3><p><font color="green" size="4" face="楷体"> 很多时候，lambda表达式的返回值( -&gt; ret)很明显，因此可以省略 </font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完整的lambda表达式定义</span></span><br><span class="line"><span class="keyword">auto</span> f = [](<span class="type">int</span> a) -&gt; <span class="type">int</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a+<span class="number">10</span>;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 忽略返回值的lambda表达式定义</span></span><br><span class="line"><span class="keyword">auto</span> f = [](<span class="type">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a+<span class="number">10</span>;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><font color="green" size="4" face="楷体"> 一般情况下，编译器会根据return语句自动推导lambda表达式的返回值类型，</font><font color="red" size="4" face="楷体">但是不能推导列表初始化的返回值类型！</font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ok，可以自动推导出返回值类型</span></span><br><span class="line"><span class="keyword">auto</span> f = [](<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error，不能推导出返回值类型</span></span><br><span class="line"><span class="keyword">auto</span> f1 = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;<span class="comment">// 基于列表初始化推导返回值，错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（4）函数本质"><a href="#（4）函数本质" class="headerlink" title="（4）函数本质"></a>（4）函数本质</h3><p><font color="green" size="4" face="楷体"> mutable可以修改按值捕获的外部变量（去掉const可读属性） </font></p><p><font color="gray" size="4" face="楷体"> 【为什么通过值拷贝的方式捕获的外部变量是只读的？】 </font></p><p><font color="green" size="4" face="楷体"> lambda表达式的类型在C++11中会被看做是一个带operator()的类，即仿函数。按照C++标准，lambda表达式的operator()默认是const的，一个const成员函数是无法修改成员变量值的。</font></p><p><font color="red" size="4" face="楷体"> 对于没有捕获任何变量的lambda表达式，还可以转换成一个普通的函数指针</font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> func_ptr = <span class="built_in">int</span>(*)(<span class="type">int</span>);</span><br><span class="line"><span class="comment">// 没有捕获任何外部变量的匿名函数</span></span><br><span class="line">func_ptr f = [](<span class="type">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 函数调用</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">1314</span>);</span><br></pre></td></tr></table></figure><p><font color="#0099aa" size="7" face="黑体">———————————————————************************************—————————————————————————–</font></p><h1 id="三、通用性能的提升"><a href="#三、通用性能的提升" class="headerlink" title="三、通用性能的提升"></a>三、通用性能的提升</h1><h2 id="1、constexpr"><a href="#1、constexpr" class="headerlink" title="1、constexpr"></a>1、constexpr</h2><h3 id="（1-1）constexpr"><a href="#（1-1）constexpr" class="headerlink" title="（1.1）constexpr"></a>（1.1）constexpr</h3><p><font color="green" size="4" face="楷体"> 用来修饰一个<font color="orange" size="4" face="楷体">常量表达式</font>（由多个常量组成并且在编译过程中就得到计算结果的表达式）</font></p><p><font color="orange" size="4" face="楷体"> 【建议】 使用中将const 和 constexpr功能区分开，凡是表达<font color="red" size="4" face="楷体">“只读”</font>语义的场景都使用 <font color="red" size="4" face="楷体">const</font>，表达<font color="red" size="4" face="楷体">“常量”</font>语义的场景都使用 <font color="red" size="4" face="楷体">constexpr</font></font></p><p><font color="orange" size="4" face="楷体"> 【不能使用constexpr修饰struct结构体或者class类】，如：</font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">T</span> &#123;</span><br><span class="line">    <span class="comment">//这是错误的！</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><font color="orange" size="4" face="楷体"> 【可以使用constexpr修饰struct&#x2F;class的一个实例】，如：</font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结构体T</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">T</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//实例</span></span><br><span class="line"><span class="keyword">constexpr</span> T t&#123;<span class="number">100</span>&#125;;<span class="comment">//这是允许的！</span></span><br></pre></td></tr></table></figure><h3 id="（1-2）常量表达式函数"><a href="#（1-2）常量表达式函数" class="headerlink" title="（1.2）常量表达式函数"></a>（1.2）常量表达式函数</h3><p><font color="green" size="4" face="楷体"> 使用constexpr修饰函数的返回值，这种函数被称作常量表达式函数</font></p><h3 id="（1）修饰函数"><a href="#（1）修饰函数" class="headerlink" title="（1）修饰函数"></a>（1）修饰函数</h3><p><font color="orange" size="4" face="楷体"> 1.函数必须要有<font color="red" size="4" face="楷体">返回值</font>，并且return <font color="red" size="4" face="楷体">返回的表达式必须是常量表达式</font>。<br>2.函数在使用之前，必须<font color="red" size="4" face="楷体">有定义语句</font>。<br>3.整个函数的函数体中，<font color="red" size="4" face="楷体">不能出现非常量表达式之外</font>的语句</font></p><h3 id="（2）修饰构造函数"><a href="#（2）修饰构造函数" class="headerlink" title="（2）修饰构造函数"></a>（2）修饰构造函数</h3><p><font color="orange" size="4" face="楷体"> 构造函数的<font color="red" size="4" face="楷体">函数体必须为空</font>，并且必须采用<font color="red" size="4" face="楷体">初始化列表的方式为各个成员赋值。</font></font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">Person</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* p, <span class="type">int</span> age)</span> :name(p), age(age)</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2、委托构造函数-继承构造函数"><a href="#2、委托构造函数-继承构造函数" class="headerlink" title="2、委托构造函数  继承构造函数"></a>2、委托构造函数  继承构造函数</h2><p><font color="green" size="4" face="楷体"> 1.委托构造函数允许使用<font color="red" size="4" face="楷体"> 同一个类中</font>的一个构造函数调用其它的构造函数，从而简化相关变量的初始化。</font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() &#123;&#125;;</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> max)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_max = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> max, <span class="type">int</span> min):<span class="built_in">Test</span>(max) <span class="comment">//委托构造</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_min = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> max, <span class="type">int</span> min, <span class="type">int</span> mid):<span class="built_in">Test</span>(max, min)  <span class="comment">//委托构造</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_middle = <span class="number">50</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_min;</span><br><span class="line">    <span class="type">int</span> m_max;</span><br><span class="line">    <span class="type">int</span> m_middle;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><font color="green" size="4" face="楷体"> 2.继承构造函数可以让<font color="red" size="4" face="楷体">派生类直接使用基类的所有构造函数</font>，而无需自己再写构造函数。</font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> i) :<span class="built_in">m_i</span>(i) &#123;&#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> i, <span class="type">double</span> j) :<span class="built_in">m_i</span>(i), <span class="built_in">m_j</span>(j) &#123;&#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> i, <span class="type">double</span> j, string k) :<span class="built_in">m_i</span>(i), <span class="built_in">m_j</span>(j), <span class="built_in">m_k</span>(k) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_i;</span><br><span class="line">    <span class="type">double</span> m_j;</span><br><span class="line">    string m_k;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::Base;   <span class="comment">// 继承父类的所有构造函数</span></span><br><span class="line">    <span class="comment">// using Base::func;    继承父类所有func重写函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3、右值引用"><a href="#3、右值引用" class="headerlink" title="3、右值引用"></a>3、右值引用</h2><p><font color="green" size="4" face="楷体"> 左值：存储在内存中、有明确存储地址的数据。<font color="red" size="4" face="楷体">（可取地址）</font><br>右值：可以提供数据值的数据。<font color="red" size="4" face="楷体">（不可取地址）</font></font></p><p><font color="green" size="4" face="楷体"> C++11 中右值可以分为两种：<br><font color="orange" size="4" face="楷体">将亡值：</font>与右值引用相关的表达式，比如，T&amp;&amp;类型函数的返回值、 std::move 的返回值等。<br><font color="orange" size="4" face="楷体">纯右值：</font>非引用返回的临时变量、运算表达式产生的临时变量、原始字面量和 lambda 表达式等</font></p><h3 id="3-1-右值引用"><a href="#3-1-右值引用" class="headerlink" title="(3.1)右值引用"></a>(3.1)右值引用</h3><h2 id="4、转移和完美转发"><a href="#4、转移和完美转发" class="headerlink" title="4、转移和完美转发"></a>4、转移和完美转发</h2><h3 id="（4-1）move"><a href="#（4-1）move" class="headerlink" title="（4.1）move"></a>（4.1）move</h3><p><font color="green" size="4" face="楷体">std::move()：可以将左值转换为右值。对象的状态或者所有权从一个对象转移到另一个对象，<font color="red" size="4" face="楷体">只是转移，没有内存拷贝。</font></font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">list&lt;string&gt; ls;</span><br><span class="line">ls.<span class="built_in">push_back</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">ls.<span class="built_in">push_back</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">......</span><br><span class="line">list&lt;string&gt; ls1 = ls;        <span class="comment">// 需要拷贝, 效率低</span></span><br><span class="line">list&lt;string&gt; ls2 = <span class="built_in">move</span>(ls);    <span class="comment">//move,转移</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><font color="orange" size="4" face="楷体">使用move几乎没有任何代价，只是转换了资源的所有权。</font></p><h3 id="（4-2）forward"><a href="#（4-2）forward" class="headerlink" title="（4.2）forward"></a>（4.2）forward</h3><p><font color="blue" size="4" face="楷体">【函数原型】：std::forward<T>(t);</T></font></p><p><font color="green" size="4" face="楷体">当T为左值引用类型时，t将被转换为T类型的左值，否则，t被转换为T类型的右值。</font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testForward</span><span class="params">(T &amp;&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printValue</span>(v);</span><br><span class="line">    <span class="built_in">printValue</span>(<span class="built_in">move</span>(v));</span><br><span class="line">    <span class="built_in">printValue</span>(forward&lt;T&gt;(v));</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">testForward</span>(<span class="number">520</span>);</span><br><span class="line">    <span class="type">int</span> num = <span class="number">1314</span>;</span><br><span class="line">    <span class="built_in">testForward</span>(num);</span><br><span class="line">    <span class="built_in">testForward</span>(forward&lt;<span class="type">int</span>&gt;(num));</span><br><span class="line">    <span class="built_in">testForward</span>(forward&lt;<span class="type">int</span>&amp;&gt;(num));</span><br><span class="line">    <span class="built_in">testForward</span>(forward&lt;<span class="type">int</span>&amp;&amp;&gt;(num));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="orange" size="4" face="楷体"> 左右右    左右左  左右右  左右左  左右右 </font></p><h2 id="5、列表初始化"><a href="#5、列表初始化" class="headerlink" title="5、列表初始化"></a>5、列表初始化</h2><h3 id="（5-1）统一的初始化"><a href="#（5-1）统一的初始化" class="headerlink" title="（5.1）统一的初始化"></a>（5.1）统一的初始化</h3><pre><code>int a = &#123;5&#125;;</code></pre><h3 id="（5-2）列表初始化细节"><a href="#（5-2）列表初始化细节" class="headerlink" title="（5.2）列表初始化细节"></a>（5.2）列表初始化细节</h3><p><font color="orange" size="4" face="楷体"> 聚合类型 ：</font><br><font color="green" size="4" face="楷体"> 1.普通数组<br>2.满足以下条件的类（class、struct、union）：<br>    1）无用户自定义的构造函数。<br>    2）无私有或保护的非静态数据成员。<br>    3）无基类。<br>    4）无虚函数。 </font><br><font color="red" size="4" face="楷体"> 【直接花括号初始化即可】 </font></p><p><font color="orange" size="4" face="楷体"> 非聚合类型 ：</font><font color="green" size="4" face="楷体">不满足以上任一条件的类就是非聚合类型 </font><br><font color="red" size="4" face="楷体"> 【需要提供对应的构造函数】 </font></p><h3 id="（5-3）std-initializer-list"><a href="#（5-3）std-initializer-list" class="headerlink" title="（5.3）std::initializer_list"></a>（5.3）std::initializer_list</h3><p><font color="orange" size="4" face="楷体"> 可以接受任意个数的<font color="red" size="4" face="楷体">具有相同类型</font>的元素。 </font></p><p><font color="orange" size="4" face="楷体"> 三个成员接口：</font><font color="green" size="4" face="楷体">size(), begin(), end() </font></p><h2 id="6、using的使用"><a href="#6、using的使用" class="headerlink" title="6、using的使用"></a>6、using的使用</h2><p><font color="red" size="5" face="楷体"> 【用法】 using 新的类型名 &#x3D; 旧的类型名 </font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> myint = <span class="type">int</span>;</span><br></pre></td></tr></table></figure><p><font color="orange" size="5" face="楷体"> using可以直接给模板定义别名，typedef不能 </font></p><h2 id="7、可调用对象包装器、绑定器"><a href="#7、可调用对象包装器、绑定器" class="headerlink" title="7、可调用对象包装器、绑定器"></a>7、可调用对象包装器、绑定器</h2><p><font color="green" size="5" face="楷体"> 1、可调用对象 </font></p><p><font color="green" size="4" face="楷体"> 函数指针、仿函数、可被转换为函数指针的类对象、类成员函数指针或类成员指针 </font></p><p><font color="red" size="5" face="楷体"> 2、包装器function </font></p><p><font color="orange" size="5" face="楷体"> 【头文件】#include “functional” </font></p><p><font color="orange" size="5" face="楷体"> 【用法】 std::function&lt;返回值类型(参数类型列表)&gt; diy_name &#x3D; 可调用对象; </font></p><p><font color="red" size="5" face="楷体"> 3、绑定器bind </font></p><p><font color="orange" size="5" face="楷体"> 【用法】： 结合占位符 </font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用绑定器绑定可调用对象和参数, 并调用得到的仿函数</span></span><br><span class="line">    <span class="built_in">bind</span>(output, <span class="number">1</span>, <span class="number">2</span>)();</span><br><span class="line">    <span class="built_in">bind</span>(output, placeholders::_1, <span class="number">2</span>)(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">bind</span>(output, <span class="number">2</span>, placeholders::_1)(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">bind</span>(output, <span class="number">2</span>, placeholders::_2)(<span class="number">10</span>, <span class="number">20</span>); <span class="comment">// 10没有作用！</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">bind</span>(output, placeholders::_1, placeholders::_2)(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="built_in">bind</span>(output, placeholders::_2, placeholders::_1)(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="8、-defaul-和-delete"><a href="#8、-defaul-和-delete" class="headerlink" title="8、&#x3D;defaul 和 &#x3D;delete"></a>8、&#x3D;defaul 和 &#x3D;delete</h2><p><font color="red" size="5" face="楷体"> 1、&#x3D; default </font></p><p><font color="orange" size="5" face="楷体"> 使用 &#x3D; defaut 指定的默认函数和类提供的<font color="red" size="5" face="楷体">默认函数是等价</font>的，不能使用 &#x3D; default 修饰类提供的默认函数以外的函数 </font></p><p><font color="red" size="5" face="楷体"> 2、&#x3D; delete </font></p><p><font color="orange" size="5" face="楷体"> 使用 &#x3D; delete 表示显示删除，<code>显式删除可以避免用户使用一些不应该使用的类的成员函数</code>，使用这种方式可以有效的防止某些类型之间自动进行隐式类型转换产生的错误 </font></p><h1 id="四、安全性"><a href="#四、安全性" class="headerlink" title="四、安全性"></a>四、安全性</h1><p><font color="orange" size="5" face="微软雅黑"> 【介绍】 在C++中没有垃圾回收机制，必须自己释放分配的内存，否则就会造成内存泄露。解决这个问题最有效的方法是使用智能指针（smart pointer）。<br>头文件 ： “memory “</font></p><p><font color="orange" size="5" face="微软雅黑"> 【原理】 智能指针是存储指向动态分配（堆）对象指针的类，用于<font color="red" size="5" face="微软雅黑">生存期的控制</font>，能够确保在离开指针所在作用域时，自动地销毁动态分配的对象，防止内存泄露。智能指针的核心实现技术是<font color="red" size="5" face="微软雅黑">引用计数</font>，每使用它一次，内部引用计数加1，每析构一次内部的引用计数减1，减为0时，删除所指向的堆内存。 </font></p><h2 id="1、共享智能指针（shared-ptr）"><a href="#1、共享智能指针（shared-ptr）" class="headerlink" title="1、共享智能指针（shared_ptr）"></a>1、共享智能指针（shared_ptr）</h2><h3 id="1、初始化方式：4种"><a href="#1、初始化方式：4种" class="headerlink" title="1、初始化方式：4种"></a>1、初始化方式：4种</h3><p><font color="orange" size="4" face="微软雅黑"> 第一种：构造函数初始化 </font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用智能指针管理一块 int 型的堆内存</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">520</span>))</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ptr1管理的内存引用计数: &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 使用智能指针管理一块字符数组对应的堆内存</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">char</span>&gt; <span class="title">ptr2</span><span class="params">(<span class="keyword">new</span> <span class="type">char</span>[<span class="number">12</span>])</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ptr2管理的内存引用计数: &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 创建智能指针对象, 不管理任何内存</span></span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; ptr3;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ptr3管理的内存引用计数: &quot;</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 创建智能指针对象, 初始化为空</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr4</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ptr4管理的内存引用计数: &quot;</span> &lt;&lt; ptr4.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><font color="red" size="4" face="微软雅黑"> 不能使用原始指针初始化多个共享指针： </font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(p)</span></span>;</span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(p)</span></span>;<span class="comment">// error, 编译不会报错, 运行会出错</span></span><br></pre></td></tr></table></figure><p><font color="orange" size="4" face="微软雅黑"> 第二种：拷贝构造函数、移动构造函数初始化 </font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">520</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用拷贝构造函数</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr2</span><span class="params">(ptr1)</span></span>;</span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; ptr3 = ptr1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用移动构造函数</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr4</span><span class="params">(move(ptr1))</span></span>;</span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; ptr5 = <span class="built_in">move</span>(ptr2);</span><br></pre></td></tr></table></figure><p><font color="red" size="4" face="微软雅黑"> 移动构造函数不会增加引用计数 </font></p><p><font color="orange" size="4" face="微软雅黑"> 第三种：通过make_shared函数初始化 </font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用智能指针管理一块 int 型的堆内存</span></span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr1 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">520</span>);</span><br></pre></td></tr></table></figure><p><font color="orange" size="4" face="微软雅黑"> 第四种：通过reset方法初始化 </font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; ptr = <span class="literal">nullptr</span>;</span><br><span class="line">ptr.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">250</span>));</span><br></pre></td></tr></table></figure><p><font color="red" size="4" face="微软雅黑"> reset() 能将共享指针的引用计数置零 </font></p><h3 id="2、获取原始指针"><a href="#2、获取原始指针" class="headerlink" title="2、获取原始指针"></a>2、获取原始指针</h3><p><font color="orange" size="4" face="微软雅黑"> get() </font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line">*p = <span class="number">100</span>;</span><br><span class="line">cout &lt;&lt; *p.<span class="built_in">get</span>() &lt;&lt; endl;  <span class="comment">// 100</span></span><br></pre></td></tr></table></figure><h3 id="3、指定删除器"><a href="#3、指定删除器" class="headerlink" title="3、指定删除器"></a>3、指定删除器</h3><p><font color="orange" size="4" face="微软雅黑"> 删除非数组类型： 不需要指定删除器</font></p><p><font color="orange" size="4" face="微软雅黑"> 删除数组类型： </font></p><p><font color="orange" size="4" face="微软雅黑"> 方法一：自写一个lanmbda表达式： </font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>], [](<span class="type">int</span>* p) &#123;<span class="keyword">delete</span>[]p; &#125;)</span></span>;</span><br></pre></td></tr></table></figure><p><font color="orange" size="4" face="微软雅黑"> 方法二：使用自带的delete_default<T>( )函数 ： </T></font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>], default_delete&lt;<span class="type">int</span>[]&gt;())</span></span>;</span><br></pre></td></tr></table></figure><p><font color="red" size="4" face="微软雅黑"> 【注意】 C++11以后可以再模板参数列表指定数组类型，就会自动释放 </font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>[]&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>])</span></span>;</span><br><span class="line">ptr.<span class="built_in">reset</span>();</span><br></pre></td></tr></table></figure><h2 id="2、独占智能指针（unique-ptr）"><a href="#2、独占智能指针（unique-ptr）" class="headerlink" title="2、独占智能指针（unique_ptr）"></a>2、独占智能指针（unique_ptr）</h2><h3 id="1、初始化方式：-3种"><a href="#1、初始化方式：-3种" class="headerlink" title="1、初始化方式： 3种"></a>1、初始化方式： 3种</h3><p><font color="orange" size="4" face="微软雅黑"> 方法一：构造函数初始化： </font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">5</span>))</span></span>;</span><br></pre></td></tr></table></figure><p><font color="orange" size="4" face="微软雅黑"> 方法二：移动构造函数初始化： </font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">5</span>))</span></span>;</span><br><span class="line">unique_ptr&lt;<span class="type">int</span>&gt; ptr2 = <span class="built_in">move</span>(ptr1);</span><br></pre></td></tr></table></figure><p><font color="orange" size="4" face="微软雅黑"> 方法三：通过reset方法初始化： </font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">5</span>))</span></span>;</span><br><span class="line">ptr.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>));</span><br></pre></td></tr></table></figure><h3 id="2、删除器"><a href="#2、删除器" class="headerlink" title="2、删除器"></a>2、删除器</h3><p><font color="orange" size="4" face="微软雅黑"> 需要在模板列表指示出，删除器类型 </font></p><h2 id="3、弱引用智能指针（weak-ptr）"><a href="#3、弱引用智能指针（weak-ptr）" class="headerlink" title="3、弱引用智能指针（weak_ptr）"></a>3、弱引用智能指针（weak_ptr）</h2><p><font color="orange" size="5" face="微软雅黑"> weak_ptr 是用来辅佐shared_ptr的，它只负责监视对应的内存，并不管理该内存<font color="red" size="5" face="微软雅黑"> （weak_ptr不改变引用计数）</font> </font></p><h3 id="1、初始化"><a href="#1、初始化" class="headerlink" title="1、初始化"></a>1、初始化</h3><p><font color="orange" size="4" face="微软雅黑"> 构造函数初始化和共享指针初始化 </font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数初始化</span></span><br><span class="line">weak_ptr&lt;<span class="type">int</span>&gt; wp1;</span><br><span class="line"><span class="comment">// 用共享指针初始化</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">5</span>))</span></span>;</span><br><span class="line"><span class="function">weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp2</span><span class="params">(ptr)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="2、常用的方法"><a href="#2、常用的方法" class="headerlink" title="2、常用的方法"></a>2、常用的方法</h3><p><font color="orange" size="4" face="微软雅黑"> use_count( ) ： 获取当前监测的内存的引用计数。</font></p><p><font color="orange" size="4" face="微软雅黑"> expired( ) ： 查看当前监测的内存是否释放？是：返回true；不是：返回false。</font></p><p><font color="orange" size="4" face="微软雅黑"> lock( ) ： 获取当前监测的内存中取出一个共享指针对象。</font></p><p><font color="orange" size="4" face="微软雅黑"> reset( ) ： 不再监测任何内存资源。</font></p><h3 id="3、解决问题"><a href="#3、解决问题" class="headerlink" title="3、解决问题"></a>3、解决问题</h3><p><font color="orange" size="4" face="微软雅黑"> 1.使用weak_ptr解决共享指针循环引用问题</font>  </p><p><font color="orange" size="4" face="微软雅黑"> 2.使用enable_shared_from_this类的shared_from_this()方法<font color="red" size="4" face="微软雅黑">（本质是里面的weak_ptr调用了lock方法）</font> ，解决内存重复释放问题</font> </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2024/02/26/C-11%E5%B8%B8%E7%94%A8%E7%89%B9%E6%80%A7/C++11.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++11" scheme="http://example.com/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>Linux高性能服务器编程学习笔记（二）</title>
    <link href="http://example.com/2023/12/21/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://example.com/2023/12/21/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2023-12-21T13:53:14.000Z</published>
    <updated>2024-02-27T11:32:06.011Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2023/12/21/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.jpg"></p><span id="more"></span><h1 id="第二部分-深入解析高性能服务器编程（5-15章）"><a href="#第二部分-深入解析高性能服务器编程（5-15章）" class="headerlink" title="第二部分 深入解析高性能服务器编程（5~15章）"></a>第二部分 深入解析高性能服务器编程（5~15章）</h1><h2 id="第5章-网络编程基础API"><a href="#第5章-网络编程基础API" class="headerlink" title="第5章 网络编程基础API"></a>第5章 网络编程基础API</h2><p>从3个方面探讨： Linux网络编程基础API 与 内核中TCP&#x2F;IP协议族之间的关系</p><pre><code>1.socket地址API：socket最开始的含义是，一个IP地址和端口对，即（IP，port）。它唯一地表示了使用TCP通信的一端，称sokect地址。2.socket基础API：定义在sys/sokect.h中，包括：创建sokect、命名sokect、监听sokect、接受连接、发起连接、读写数据、获取地址信息、检测带外标记、，以及读取和设置sokect选项。3.网络信息API：定义在netdb.h中，实现主机名和IP地址之间的转换、服务名称和端口号之间的转换。</code></pre><h3 id="5-1-sokect地址API"><a href="#5-1-sokect地址API" class="headerlink" title="5.1 sokect地址API"></a>5.1 sokect地址API</h3><h4 id="5-1-1-主机字节序和网络字节序"><a href="#5-1-1-主机字节序和网络字节序" class="headerlink" title="5.1.1 主机字节序和网络字节序"></a>5.1.1 主机字节序和网络字节序</h4><p>1.主机字节序</p><pre><code>字节序问题：4字节一个整数，这4个字节在内存中的排列顺序将影响它被累加器装在成的整数的值。大端字节序（big endian）：高位字节存储在内存的低地址处，低位字节存储在内存的高地址处小端字节序（little endian）：高位字节——&gt;内存高地址，低位字节——&gt;内存低地址</code></pre><p>注意：现在PC大多采用小端字节序，因此小端字节序也称为主机字节序。</p><p>2.网络字节序</p><pre><code>发送端总要把发送的数据转换成大端字节序再发送，接收端根据自身采用的字节序决定是否需要转换字节序。因此大端字节序也称为网络字节序。注意：同一台机器上的两个进程间的通信，也要考虑字节序的问题！</code></pre><p>3.Linux提供了四个函数，完成主机字节序和网络字节序之间的转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="comment">//host to network long 将长整型主机字节序转换为网络字节序</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="title">hton</span><span class="params">( <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> hostlong )</span></span>; </span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="title">htons</span><span class="params">( <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> hostshort )</span></span>;</span><br><span class="line"><span class="comment">//network to host long 将长整型网络字节序转换为主机字节序</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="title">ntol</span><span class="params">( <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> netlong )</span></span>;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="title">ntohs</span><span class="params">( <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> netshort )</span></span>;</span><br></pre></td></tr></table></figure><pre><code>一般长整型函数用来转换IP地址，短整型函数一般用来转换端口号（当然不限于此，任何通过格式化的数据通过网络传输时都应该使用这些函数来转换字节序！）</code></pre><h4 id="5-1-2-通用sokect地址"><a href="#5-1-2-通用sokect地址" class="headerlink" title="5.1.2 通用sokect地址"></a>5.1.2 通用sokect地址</h4><p>sokect网络编程接口中标识sokect地址的时结构体sockaddr：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr</span> &#123;</span><br><span class="line">    <span class="type">sa_family_t</span> sa_family;</span><br><span class="line">    <span class="type">char</span> sa_data[<span class="number">14</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code>sa_family是地址族类型（sa_family_t）的变量，地址族通常与协议族对应。sa_data成员用于存放sokect地址值。由于sa_data无法容纳多数的协议族地址值。所以linux定义了新的通用sokcet地址：</code></pre><p>新的通用sokect地址：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个结构体不但提供了足够的内存空间存放地址值，而且是内存对齐的（__ss_align成员的作用！）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_storage</span>&#123;</span><br><span class="line">    <span class="type">sa_family_t</span> sa_family;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> __ss_align;</span><br><span class="line">    <span class="type">char</span> __ss_padding[<span class="number">128</span>-<span class="built_in">sizeof</span>(__ss_align )];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="5-1-3-专用sokect地址"><a href="#5-1-3-专用sokect地址" class="headerlink" title="5.1.3 专用sokect地址"></a>5.1.3 专用sokect地址</h4><pre><code>通用sokcet地址不好用，涉及繁琐的位操作，所以linux让各个协议族提供了专门的sokect地址结构体：</code></pre><p>1.UNIX本地协议族：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_un</span> &#123;</span><br><span class="line">    <span class="type">sa_family_t</span> sin_family; <span class="comment">//地址族：AF_UNIX</span></span><br><span class="line">    <span class="type">char</span> sun_path[<span class="number">108</span>];     <span class="comment">//文件路径名</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.TCP&#x2F;IP协议族有两个专用sokect地址结构体：IPv4和IPv6</p><p>IPv4：sockaddr_in</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> &#123;</span><br><span class="line">    <span class="type">sa_family_t</span> sin_family; <span class="comment">//地址族：AF_INET</span></span><br><span class="line">    <span class="type">u_int16_t</span> sin_port;     <span class="comment">//端口号：要用网络字节序表示</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> sin_addr;<span class="comment">//IPv4地址结构体</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span> &#123;</span><br><span class="line">    <span class="type">u_int32_t</span> s_addr;       <span class="comment">//IPv4地址，要用网络字节序表示</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IPv6：sockaddr_in6</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in6</span> &#123;</span><br><span class="line">    <span class="type">sa_family_t</span> sin6_family;    <span class="comment">//地址族：AF_INET6</span></span><br><span class="line">    <span class="type">u_int16_t</span> sin6_port;        <span class="comment">//端口号：要用网络字节序表示</span></span><br><span class="line">    <span class="type">u_int32_t</span> sin6_flowinfo;    <span class="comment">//流信息：应设置为0</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in6_addr</span> sin6_addr;  <span class="comment">//IPv6地址结构体</span></span><br><span class="line">    <span class="type">u_int32_t</span> sin6_scope_id;    <span class="comment">//scope ID，尚处于实验阶段</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in6_addr</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> sa_addr[<span class="number">16</span>];  <span class="comment">//IPv6地址：要用网络字节序表示</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：所有专用sokcet地址（以及sockaddr_storage）类型的变量，在实际使用时，都需要转化为通用sokect地址类型sockaddr（强制转换即可），因为所有sokcet编程接口使用的地址参数类型都是sockaddr。</p><h4 id="5-1-4-IP地址转化函数"><a href="#5-1-4-IP地址转化函数" class="headerlink" title="5.1.4 IP地址转化函数"></a>5.1.4 IP地址转化函数</h4><p>点分十进制字符串IPv4地址  与  网络字节序整数IPv4地址转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">//点分十进制IPv4——&gt;网络字节IPv4</span></span><br><span class="line"><span class="function"><span class="type">in_addr_t</span> <span class="title">inet_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* strptr)</span></span>;     </span><br><span class="line"><span class="comment">//与上面功能一样，但将转换结果存储在参数inp指向的地址结构体中</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">inet_aton</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* cp, strcut in_addr* inp)</span></span>; </span><br><span class="line"><span class="comment">//网络字节IPv4——&gt;点分十进制IPv4</span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr in)</span></span>;<span class="comment">//需要注意的是，该函数内部用一个静态变量存储转化结果，返回值指向静态内存</span></span><br></pre></td></tr></table></figure><p>下面这对更新的函数能够完成上述三个函数同样的功能，并且能适用于IPv4和IPv6：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#inclued<span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">//将字符串表示的IP地址src 转化成网络字节序表示的IP地址，并存储与dst指向的内存中</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span>* src, <span class="type">void</span>* dst)</span></span>;</span><br><span class="line"><span class="comment">//与上面转化相反，</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span>* src, <span class="type">char</span>* dst, <span class="type">socklen_t</span> cnt)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-2-创建socket"><a href="#5-2-创建socket" class="headerlink" title="5.2 创建socket"></a>5.2 创建socket</h3><pre><code>socket就是可读、可写、可控制、可关闭的文件描述符。</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure><pre><code>domain:使用哪个底层协议族，对于TCP/IP而言：PF_INET或者PF_INET6;对于UNIX本地域协议族而言，PF_UNIX;type：指定服务类型。SOCK_STREAM(流服务)——TCP； SOCK_UGRAM(数据报服务)——UDP；protocol:一般设置为0；</code></pre><h3 id="5-3-命名socket"><a href="#5-3-命名socket" class="headerlink" title="5.3 命名socket"></a>5.3 命名socket</h3><p>未完待续..</p><hr><h2 id="第6章-高级I-O函数"><a href="#第6章-高级I-O函数" class="headerlink" title="第6章 高级I&#x2F;O函数"></a>第6章 高级I&#x2F;O函数</h2><p>大致分为三类：</p><pre><code>1.用于创建文件描述符的函数：包括pipe、dup/dup2函数2.用于读写数据的函数：包括readv/writev/、sendfile、mmap/munmap、splice和tee函数3.用于控制I/O行为和属性的函数，包括fcntl函数</code></pre><h3 id="6-1-pipe函数"><a href="#6-1-pipe函数" class="headerlink" title="6.1 pipe函数"></a>6.1 pipe函数</h3><pre><code>作用：可用于创建一个管道，实现进程间通信。</code></pre><p>定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pipe</span><span class="params">(<span class="type">int</span> fd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure><p>注意：</p><pre><code>1.pipe函数的参数是，一个包含两个int整数的数组指针。2.通过pipe函数创建的这两个文件描述符fd[0]和fd[1],分别构成了管道的两端。3.fd[0]只能用于从管道读数据，fd[1]只能用于往管道写数据，而不能反过来使用。4.如果要实现双向传输数据，则需要两个管道。5.默认情况下，这两个文件描述符都是阻塞的。6.如果用read读取一个空管道，则read将被阻塞；如果用write往一个满的管道写数据，write也将被阻塞。7.可以使用fcntl函数修改管道容量</code></pre><p>此外：</p><pre><code>socketpair函数：能够方便的创建双向管道：</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/tpyes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">socketpair</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> tpye, <span class="type">int</span> protocol, <span class="type">int</span> fd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure><h3 id="6-2-dup-函数和dup2-函数"><a href="#6-2-dup-函数和dup2-函数" class="headerlink" title="6.2 dup 函数和dup2 函数"></a>6.2 dup 函数和dup2 函数</h3><pre><code>作用：用于复制文件描述符</code></pre><p>定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dup</span><span class="params">(<span class="type">int</span> file_descriptor)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dup2</span><span class="params">(<span class="type">int</span> file_descriptor_one, <span class="type">int</span> file_descriptor_two)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="6-3-readv-函数和writev-函数"><a href="#6-3-readv-函数和writev-函数" class="headerlink" title="6.3 readv 函数和writev 函数"></a>6.3 readv 函数和writev 函数</h3><pre><code>作用：    readv函数将数据从文件描述符读到分散的内存块中，即分散读；    writev函数将多块分散的内存块数据一并读到文件描述符，即集中写；</code></pre><p>定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">readv</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec* vector, <span class="type">int</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">writev</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec* vector, <span class="type">int</span> count)</span></span>;</span><br></pre></td></tr></table></figure><p>解释：</p><pre><code>fd是被操作的文件描述符；vector参数的类型是iovec结构数组，该结构体描述一块内存区。count是vector数组的长度，即有多少块内存需要从fd读出或写到fd。</code></pre><h3 id="6-4-sendfile-函数"><a href="#6-4-sendfile-函数" class="headerlink" title="6.4 sendfile 函数"></a>6.4 sendfile 函数</h3><pre><code>作用：sendfile 函数在两个文件描述符之间直接传递数据（完全在内核中操作），从而避免了内核缓冲区和用户缓冲区，之间的数据拷贝，效率很高，这被称为零拷贝。</code></pre><p>定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/sendfile.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">sendfile</span><span class="params">(<span class="type">int</span> out_fd, <span class="type">int</span> in_fd, <span class="type">off_t</span>* offset, <span class="type">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure><p>解释:</p><pre><code>in_fd待读出内容的文件描述符out_fd是待写入内容的文件描述符offset指定从读入文件流的哪个位置开始读，如果为空，则默认从起始位置。count指定在in_fd和out_fd之间传输的字节数</code></pre><h3 id="6-5-mmap-函数和-munmap函数"><a href="#6-5-mmap-函数和-munmap函数" class="headerlink" title="6.5 mmap 函数和 munmap函数"></a>6.5 mmap 函数和 munmap函数</h3><pre><code>作用：mmap函数用于申请一段内存空间，munmap函数则释放有mmap创建的这段内存空间。</code></pre><p>定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/mmap.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">map</span><span class="params">(<span class="type">void</span>* start, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">munmap</span><span class="params">(<span class="type">void</span>* start, <span class="type">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure><p>解释：</p><pre><code>start：允许用于将某个特定地址作为这段内存的起始地址length：指定这段内存的长度prot：设置这段内存的访问权限：PROT_READ,内存段可读；PROT_WRITE,内存段可写；PROT_EXEC,可执行；PROT_NONE,不可访问flags：控制内存段被修改后程序的行为fd：指被映射文件对应的文件描述符，一般通过open系统调用获得offset：设置从文件的何处开始映射</code></pre><h3 id="6-6-splice-函数"><a href="#6-6-splice-函数" class="headerlink" title="6.6 splice 函数"></a>6.6 splice 函数</h3><pre><code>作用：用于在两个文件描述符之间移动数据，也是零拷贝操作。</code></pre><p>定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">splice</span><span class="params">(<span class="type">int</span> fd_in, <span class="type">loff_t</span>* offin, <span class="type">int</span> fd_out, <span class="type">loff_t</span>* off_out, <span class="type">size_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><p>解释：</p><pre><code>fd_in：待输入数据的文件描述符offin：若fd_in是管道文件描述符，则必须设置为NULL；反之，表示从输入流的何处开始读取数据len：指定移动数据的长度flags：控制数据如何移动</code></pre><p>使用splice函数时，fd_in和fd_out必须至少有一个是管道文件描述符。</p><h3 id="6-7-tee-函数"><a href="#6-7-tee-函数" class="headerlink" title="6.7 tee 函数"></a>6.7 tee 函数</h3><pre><code>作用：在两个管道文件描述符之间复制数据，也是零拷贝操作。</code></pre><p>定义:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">tee</span><span class="params">(<span class="type">int</span> fd_in, <span class="type">int</span> fd_out, <span class="type">size_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><p>解释：</p><pre><code>fd_in和fd_out都必须是管道文件描述符</code></pre><h3 id="6-8-fcntl-函数"><a href="#6-8-fcntl-函数" class="headerlink" title="6.8 fcntl 函数"></a>6.8 fcntl 函数</h3><pre><code>作用：提供了对文件描述符的各种控制操作</code></pre><p>定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ...)</span></span>;</span><br></pre></td></tr></table></figure><p>解释：</p><pre><code>fd：被操作的文件描述符cmd：指定执行何种类型的操作，根据类型不同，可能还需第三个参数arg</code></pre><p>在网络编程中，fcntl函数通常用来将一个文件描述符设置为非阻塞的。</p><hr><h2 id="第7章-Linux服务器程序规范"><a href="#第7章-Linux服务器程序规范" class="headerlink" title="第7章 Linux服务器程序规范"></a>第7章 Linux服务器程序规范</h2><pre><code>服务器程序的一些主要规范：日志、PID文件、系统资源占用、配置文件等等。。。</code></pre><h3 id="7-1-日志"><a href="#7-1-日志" class="headerlink" title="7.1 日志"></a>7.1 日志</h3><h4 id="7-1-1-Linux系统日志"><a href="#7-1-1-Linux系统日志" class="headerlink" title="7.1.1 Linux系统日志"></a>7.1.1 Linux系统日志</h4><pre><code>rsyslogd守护进程：既能接收用户进程输出的日志，又能接收内核日志。</code></pre><h4 id="7-1-2-syslog-函数"><a href="#7-1-2-syslog-函数" class="headerlink" title="7.1.2 syslog 函数"></a>7.1.2 syslog 函数</h4><pre><code>作用：应用程序使用syslog函数与rsyslogd守护进程通信。</code></pre><p>定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="function">viud <span class="title">stslog</span><span class="params">(<span class="type">int</span> priority, <span class="type">const</span> <span class="type">char</span>* message, ...)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="7-2-用户信息"><a href="#7-2-用户信息" class="headerlink" title="7.2 用户信息"></a>7.2 用户信息</h3><h4 id="7-2-1-UID、EUID、GID、EGID"><a href="#7-2-1-UID、EUID、GID、EGID" class="headerlink" title="7.2.1 UID、EUID、GID、EGID"></a>7.2.1 UID、EUID、GID、EGID</h4><pre><code>UID:真实用户IDEUID:有效用户IDGID:真实组IDEGID:有效组ID</code></pre><p>函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/tpyes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">uid_t</span> <span class="title">getuid</span><span class="params">()</span></span>;         <span class="comment">//获取真是用户id</span></span><br><span class="line"><span class="function"><span class="type">uid_t</span> <span class="title">geteuid</span><span class="params">()</span></span>;        <span class="comment">//获取有效用户id</span></span><br><span class="line"><span class="function"><span class="type">gid_t</span> <span class="title">getgid</span><span class="params">()</span></span>;         <span class="comment">//获取真实组id</span></span><br><span class="line"><span class="function"><span class="type">gid_t</span> <span class="title">getegid</span><span class="params">()</span></span>;        <span class="comment">//获取有效组id</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setuid</span><span class="params">(<span class="type">uid_t</span> uid)</span></span>;  <span class="comment">//设置真是用户id</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">seteuid</span><span class="params">(<span class="type">uid_t</span> uid)</span></span>; <span class="comment">//设置有效用户id</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setgid</span><span class="params">(<span class="type">gid_t</span> gid)</span></span>;  <span class="comment">//设置真实组id</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">segegid</span><span class="params">(<span class="type">gid_t</span> gid)</span></span>; <span class="comment">//设置有效组id</span></span><br></pre></td></tr></table></figure><p>需要指出的是：</p><pre><code>一个进程拥有两个用户ID：UID和EUID。 EUID存在的目的是方便资源访问。</code></pre><h4 id="7-2-2-用户切换"><a href="#7-2-2-用户切换" class="headerlink" title="7.2.2 用户切换"></a>7.2.2 用户切换</h4><h3 id="7-3-进程间关系"><a href="#7-3-进程间关系" class="headerlink" title="7.3 进程间关系"></a>7.3 进程间关系</h3><h4 id="7-3-1-进程组"><a href="#7-3-1-进程组" class="headerlink" title="7.3.1 进程组"></a>7.3.1 进程组</h4><pre><code>Linux下每个进程都隶属于一个进程组，因此它们除了PID信息外，还有进程组ID（PGID）。</code></pre><p>通过以下函数获取指定进程的PGID：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">getpgid</span><span class="params">(<span class="type">pit_t</span> pid)</span></span>;</span><br></pre></td></tr></table></figure><p>注意：</p><pre><code>1.每个进程组都有一个首领进程，其PGID和PID相同。2.进程组将一直存在，直到其中所有进程都推出，或加入到其他进程组。</code></pre><p>通过以下函数设置PGID：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">//该函数将PID为pid的进程的PGID设置为pgid</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setpgid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid)</span></span>;</span><br></pre></td></tr></table></figure><p>注意：</p><pre><code>1.一个进程只能设置自己或者其子进程的PGID2.当子进程调用exec系列函数后，不能再在父进程中对它设置PGID</code></pre><h4 id="7-3-2-会话"><a href="#7-3-2-会话" class="headerlink" title="7.3.2 会话"></a>7.3.2 会话</h4><pre><code>一些有关联的进程组将形成一个会话（session）</code></pre><p>创建会话：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">setsid</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>注意：</p><pre><code>该函数不能由进程组的首领进程调用。</code></pre><p>获取会话ID：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">getsid</span><span class="params">(<span class="type">pid_t</span> pid)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="7-3-3-用ps命令查看进程关系"><a href="#7-3-3-用ps命令查看进程关系" class="headerlink" title="7.3.3 用ps命令查看进程关系"></a>7.3.3 用ps命令查看进程关系</h4><h3 id="7-4-系统资源限制"><a href="#7-4-系统资源限制" class="headerlink" title="7.4 系统资源限制"></a>7.4 系统资源限制</h3><p>Linux系统资源限制通过如下一对函数进行读取和设置：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getrlimit</span><span class="params">(<span class="type">int</span> resource, <span class="keyword">struct</span> rlimit* rlim)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setrlimit</span><span class="params">(<span class="type">int</span> resource, <span class="type">const</span> <span class="keyword">struct</span> rlimit* rlim)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">rlimit</span> &#123;</span><br><span class="line">    <span class="type">rlim_t</span> rlim_cur;</span><br><span class="line">    <span class="type">rlim_t</span> rlim_max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="7-5-改变工作目录和根目录"><a href="#7-5-改变工作目录和根目录" class="headerlink" title="7.5 改变工作目录和根目录"></a>7.5 改变工作目录和根目录</h3><p>获取进程当前工作目录、改变进程工作目录：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">getcwd</span><span class="params">(<span class="type">char</span>* buf, <span class="type">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cndir</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path)</span></span>;</span><br></pre></td></tr></table></figure><p>改变进程根目录：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">chroot</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="7-6-服务器程序后台化"><a href="#7-6-服务器程序后台化" class="headerlink" title="7.6 服务器程序后台化"></a>7.6 服务器程序后台化</h3><pre><code>讨论如何在代码中，让一个进程以守护进程的方式运行。</code></pre><p>Linux提供的库函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">daemon</span> <span class="params">(<span class="type">int</span> nochdir, <span class="type">int</span> noclose)</span></span>;</span><br></pre></td></tr></table></figure><p>解释：</p><pre><code>nochdir：用于指定是否改变工作目录，如果传递0，则工作目录将被设置为“/”根目录，否则继续使用当前工作目录。noclose：为0时，标准输入、标准输出和标准错误输出都被重定向到/dev/null文件，否则依然使用原来的设备。</code></pre><hr><h2 id="第8章-高性能服务器程序框架"><a href="#第8章-高性能服务器程序框架" class="headerlink" title="第8章 高性能服务器程序框架"></a>第8章 高性能服务器程序框架</h2><p>将服务器解构为如下三个主要模块：</p><pre><code>1.I/O处理单元。2.逻辑单元。3.存储单元。</code></pre><h3 id="8-1-服务器模型"><a href="#8-1-服务器模型" class="headerlink" title="8.1 服务器模型"></a>8.1 服务器模型</h3><h4 id="8-1-1-C-S模型"><a href="#8-1-1-C-S模型" class="headerlink" title="8.1.1 C&#x2F;S模型"></a>8.1.1 C&#x2F;S模型</h4>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2023/12/21/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Linus高性能服务器编程学习笔记（一）</title>
    <link href="http://example.com/2023/12/12/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B(%E4%B8%80)/"/>
    <id>http://example.com/2023/12/12/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B(%E4%B8%80)/</id>
    <published>2023-12-12T12:24:11.000Z</published>
    <updated>2024-02-26T12:45:17.255Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2023/12/12/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B(%E4%B8%80)/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.jpg"></p><span id="more"></span><h1 id="第一部分-TCP-IP协议详解（1-4章）"><a href="#第一部分-TCP-IP协议详解（1-4章）" class="headerlink" title="第一部分 TCP&#x2F;IP协议详解（1~4章）"></a>第一部分 TCP&#x2F;IP协议详解（1~4章）</h1><h2 id="第一章-TCP-IP协议族"><a href="#第一章-TCP-IP协议族" class="headerlink" title="第一章 TCP&#x2F;IP协议族"></a>第一章 TCP&#x2F;IP协议族</h2><h3 id="1-1-TCP-IP协议族体系结构以及主要协议"><a href="#1-1-TCP-IP协议族体系结构以及主要协议" class="headerlink" title="1.1 TCP&#x2F;IP协议族体系结构以及主要协议"></a>1.1 TCP&#x2F;IP协议族体系结构以及主要协议</h3><p>TCP&#x2F;IP协议族是一个四层协议系统：自底而上分别是数据链路层、网络层、传输层、应用层</p><p><img src="/2023/12/12/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B(%E4%B8%80)/image.png" alt="TCP/IP四层协议系统"></p><!--more--><h4 id="1-1-1-数据链路层"><a href="#1-1-1-数据链路层" class="headerlink" title="1.1.1 数据链路层"></a>1.1.1 数据链路层</h4><p>1.常用的协议：ARP协议（地址解析协议）、RARP协议（逆地址解析协议）</p><p>2.作用：实现了IP地址和物理MAC地址之间的转换。</p><h4 id="1-1-2-网络层"><a href="#1-1-2-网络层" class="headerlink" title="1.1.2 网络层"></a>1.1.2 网络层</h4><p>1.常用协议：IP协议、ICMP协议</p><p>2.作用：实现数据包的选路和转发。</p><p>3.方式：IP协议根据数据包的IP地址，使用逐跳（hop by hop）的方式确定通信路径。</p><p>4.注意：ICMP协议并非严格意义上的网络层，因为它使用的是处于同一层的IP协议提供的服务。（一般上层协议使用下层协议提供的服务）</p><h4 id="1-1-3-传输层"><a href="#1-1-3-传输层" class="headerlink" title="1.1.3 传输层"></a>1.1.3 传输层</h4><p>1.常用协议：TCP协议、UDP协议、SCTP协议</p><p>2.作用：为两台主机上的应用程序提供端到端的通信。</p><p>3.方式：</p><pre><code>（1）TCP：为应用层提供可靠的、面向连接的、基于流的服务。        前提：使用双方必须先建立TCP连接（2）UDP：为应用层提供不可靠的、无连接的、基于数据报的服务。（3）SCTP：本书不讨论。</code></pre><h4 id="1-1-4-应用层"><a href="#1-1-4-应用层" class="headerlink" title="1.1.4 应用层"></a>1.1.4 应用层</h4><p>1.常用协议：DNS协议、telnet协议、ping（工具）</p><p>2.作用：处理应用程序的逻辑</p><h3 id="1-2-封装"><a href="#1-2-封装" class="headerlink" title="1.2 封装"></a>1.2 封装</h3><pre><code>上层协议到底是如何使用下层协议提供的服务的呢？——————通过封装实现（应用层）应用数据——&gt;（传输层）TCP\UDP封装成TCO段\UDP数据报——&gt;（网络层）IP封装成IP数据报——&gt;（数据链路层）封装成帧至此封装结束，帧才是最终在物理网络上传送的字节序列！</code></pre><p><img src="/2023/12/12/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B(%E4%B8%80)/image-1.png" alt="封装"></p><h3 id="1-3-分用"><a href="#1-3-分用" class="headerlink" title="1.3 分用"></a>1.3 分用</h3><pre><code>分用：帧到达目的主机后，依次自底向上处理各自层的数据，并将最后处理好的帧交给目标应用程序。</code></pre><p><img src="/2023/12/12/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B(%E4%B8%80)/image-2.png" alt="分用"></p><pre><code>原应用程序——&gt;原始数据——&gt;封装——&gt;分用——&gt;目标应用程序在顶层目标服务看来，封装和分用似乎没有发生过。</code></pre><h3 id="1-4-测试网络（略）"><a href="#1-4-测试网络（略）" class="headerlink" title="1.4 测试网络（略）"></a>1.4 测试网络（略）</h3><h3 id="1-5-ARP工作原理"><a href="#1-5-ARP工作原理" class="headerlink" title="1.5 ARP工作原理"></a>1.5 ARP工作原理</h3><pre><code>本书仅讨论从IP地址——&gt;以太网（MAC）地址的转换。原理：主机向自己所在网络广播一个ARP请求，该请求包含目标机器的网络地址。网络上的所有机器都将收到这个请求，但只有目的主机会回应一个应答，该应答包含目的主机自己的物理MAC地址。</code></pre><div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"theme":"#FADFA3","loop":true,"video":{"url":"/2023/12/12/Linux高性能服务器编程(一)/ARP请求.mp4","pic":"1.png"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><div id="dplayer1" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer1"),"theme":"#FADFA3","loop":true,"video":{"url":"/2023/12/12/Linux高性能服务器编程(一)/ARP应答.mp4","pic":"1.png"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><h4 id="1-5-1-ARP高速缓存"><a href="#1-5-1-ARP高速缓存" class="headerlink" title="1.5.1 ARP高速缓存"></a>1.5.1 ARP高速缓存</h4><pre><code>ARP高速缓存：包含经常访问或最近访问的机器的 IP地址到MAC地址的映射。作用：避免了重复的ARP请求，提高了发送数据包的速度。</code></pre><h3 id="1-6-DNS工作原理"><a href="#1-6-DNS工作原理" class="headerlink" title="1.6 DNS工作原理"></a>1.6 DNS工作原理</h3><pre><code>作用：通常我们使用机器的域名来访问机器，而不是直接使用其IP地址，比如访问因特网的网站。那么将机器的域名转换为IP地址，就需要用到 域名查询服务。DNS：一种域名查询服务，将机器的域名转换为IP地址。</code></pre><h4 id="1-6-1-DNS查询和应答报文详解"><a href="#1-6-1-DNS查询和应答报文详解" class="headerlink" title="1.6.1 DNS查询和应答报文详解"></a>1.6.1 DNS查询和应答报文详解</h4><pre><code>DNS：一套分布式的域名服务系统。每个DNS服务器存放这大量的 机器名和IP地址映射,并且是动态更新的。</code></pre><h3 id="1-7-socket和TCP-IP协议族的关系"><a href="#1-7-socket和TCP-IP协议族的关系" class="headerlink" title="1.7 socket和TCP&#x2F;IP协议族的关系"></a>1.7 socket和TCP&#x2F;IP协议族的关系</h3><pre><code>前文提到，下三层（数据链路层、网络层、传输层）协议是在内核中实现的，因此操作系统需要实现一组系统调用，让应用程序能够访问这些协议提供的服务。实现这组系统调用的API主要有两套：soket和XTI，XTI已基本不再使用。</code></pre><p>socket定义的这组API提供如下两个功能：</p><pre><code>1.将应用程序数据从 用户缓冲区 中复制到TCP/UDP 内核发送缓冲区，以交付内核来发送数据；或者从 TCP/UDP接收缓冲区 复制数据到 用户缓冲区，以读取数据。2.应用程序可以通过它们修改内核中各层协议的某些头部信息或者数据结构，从而控制底层通信行为。（比如通过setsockopt函数设置IP数据报在网络中的存活时间）。</code></pre><hr><h2 id="第二章-IP协议详解"><a href="#第二章-IP协议详解" class="headerlink" title="第二章 IP协议详解"></a>第二章 IP协议详解</h2><pre><code>IP协议是TCP/IP协议的核心协议，也是socket网络编程的基础之一。主要从两方面深入探讨IP协议：    1.IP头部信息：IP头部信息出现在每个IP数据报中，用于指定IP通信的源端IP地址、目的IP地址，指导IP分片和重组，以及指定部分通信行为。    2.IP数据报的路由和转发：IP数据报的路由和转发发生在 除目标主机之外 的所有主机和路由器上。它们决定数据报是否应该转发及如何转发。 </code></pre><h3 id="2-1-IP服务的特点"><a href="#2-1-IP服务的特点" class="headerlink" title="2.1 IP服务的特点"></a>2.1 IP服务的特点</h3><pre><code>IP协议是TCP/IP协议族的动力，为上层提供无状态、无连接、不可靠的服务。    1.无状态：IP通信双方不同步传输数据的状态信息，因此所有IP数据报的发送、传输、接收都是相互独立、没有上下文关系的。        （1）缺点：无法处理乱序的、重复的IP数据报        （2）优点：简单、高效        2.无连接：IP通信双方都不长久的维持对方的任何信息。因此，上层协议每次发送数据报的时候，都必须明确指定对方的IP地址。        3.不可靠：IP协议不能保证IP数据报准确的到达接收端，只是承诺“尽最大努力”。        发送端一旦检测到IP数据报发送失败，就通知上层协议发送失败，而且不会重传。因此，使用IP服务的上层协议（如TCP协议）需要自己实现数据确认、超时重传等机制以达到可靠传输的目的。</code></pre><h3 id="2-2-IPv4头部结构"><a href="#2-2-IPv4头部结构" class="headerlink" title="2.2 IPv4头部结构"></a>2.2 IPv4头部结构</h3><h4 id="2-2-1-IPv4头部结构"><a href="#2-2-1-IPv4头部结构" class="headerlink" title="2.2.1 IPv4头部结构"></a>2.2.1 IPv4头部结构</h4><pre><code>IPv4头部结构通常为 20字节 + 40字节（选项部分）= 最长60字节   //1字节=8比特/位</code></pre><p><img src="/2023/12/12/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B(%E4%B8%80)/image-3.png" alt="IPv4头部结构"></p><p>第一行：</p><pre><code>4位版本号：指定IP协议的版本，其值是4。4位头部长度：标志该IP头部有多少个4字节。因为4为最多能表示15，所以IP头部最长为60字节。8位服务类型：    3位优先权字段（现已忽略）    4位服务类型字段（最小延迟、最大吞吐量、最高可靠性、最小费用，只能有一个置1，应用程序根据实际需要设置）    1位保留字段（必须置0）16位总长度：标识该IP数据报的总长度，以字节为单位。由于MTU（最大传输单元）限制，长度超过MTU的数据报将被分片传输，所以实际传输的IP数据报都远远没有达到最大长度。</code></pre><p>第二行：（实现分片）</p><pre><code>16位标识：每个IP数据报的唯一标识，初始值由系统随机生成：每发送一个数据报，其值就加1。同一个数据报的所有分片都具有相同的标识值。3位标志：    第一位保留。    第二位：DF（Don&#39;t Fragment）表示“禁止分片”。如果设置了DF位，且IP数据报长度超过了MTU，那么IP模块会丢弃该数据报并返回一个ICMP差错报文。    第三位：MF（More Fragment）表示“更多分片”。除了数据报的最后一个分片外，其他分片都要设置为113位分片偏移：分片相对于原始数据报开始处的偏移。除了最后一个分片外，其他分片的数据部分长度必须是8的整倍数</code></pre><p>第三行：</p><pre><code>8位生存时间：TTL（Time To Live）是数据报到达目的地前允许经过路由的跳数。每经过一个路由，TTL值被路由器-1。    TTL减为0时，路由器将丢弃数据报，并向源端发送一个ICMP差错报文。    TTL值可以防止数据报陷入路由循环。8位协议：用来区分上层协议：    ICMP是1，注意ICMP是和IP同层的！    TCP是6    UDP是1716位头部校验：由发送端填充，接收端使用CRC算法以校验IP数据报头部（注意，仅校验头部）在传输过程中是否损坏。</code></pre><p>第四行、第五行：</p><pre><code>32位源端IP地址 + 32位目的端IP地址</code></pre><p>第六行：</p><pre><code>可变长的可选信息字段：这部分最多包含40个字节。    可用选项：记录路由、时间戳、松散源路由选择(必须经过所指路由器)、严格源路由选择（只能经过所指路由器）</code></pre><h3 id="2-3-IP分片"><a href="#2-3-IP分片" class="headerlink" title="2.3 IP分片"></a>2.3 IP分片</h3><pre><code>1.当IP数据报长度超过MTU时候，将被分片传输。2.分片可能发生在发送端、中转路由器上，也可能在传输过程中被多次分片，但只有在最终的目标机器上，这些分片才会被IP模块重组。3.同一个IP数据报的每个分片都有自己的IP头部，它们具有相同的标识值，但具有不同的片偏移。4.除了最后一个分片外，其余分片都将设置MF标志。5.以太网帧的MTU是1500字节（1480字节数据部分 + 20字节IP头部）</code></pre><p><img src="/2023/12/12/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B(%E4%B8%80)/image.png" alt="分片"></p><h3 id="2-4-IP路由"><a href="#2-4-IP路由" class="headerlink" title="2.4 IP路由"></a>2.4 IP路由</h3><pre><code>IP协议的一个核心任务就是数据报的路由————决定数据报到目标机器的路径。</code></pre><h4 id="2-4-1-IP模块工作流程"><a href="#2-4-1-IP模块工作流程" class="headerlink" title="2.4.1 IP模块工作流程"></a>2.4.1 IP模块工作流程</h4><p><img src="/2023/12/12/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B(%E4%B8%80)/image-4.png" alt="IP模块工作流程"></p><h3 id="2-5-IP转发"><a href="#2-5-IP转发" class="headerlink" title="2.5 IP转发"></a>2.5 IP转发</h3><pre><code>不是转发给本机的IP数据报，将交由数据报转发子模块处理。路由器都能执行数据报的转发功能，而主机一般只发送和接受数据。</code></pre><h3 id="2-6-重定向"><a href="#2-6-重定向" class="headerlink" title="2.6 重定向"></a>2.6 重定向</h3><pre><code>ICMP重定向报文也能更新路由表。</code></pre><h4 id="2-6-1-ICMP重定向报文"><a href="#2-6-1-ICMP重定向报文" class="headerlink" title="2.6.1 ICMP重定向报文"></a>2.6.1 ICMP重定向报文</h4><p><img src="/2023/12/12/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B(%E4%B8%80)/image-5.png" alt="ICMP重定向报文"></p><pre><code>一般来说，主机只能接受ICMP重定向报文，路由器只能发送ICMP重定向报文。</code></pre><h3 id="2-7-IPv6头部结构"><a href="#2-7-IPv6头部结构" class="headerlink" title="2.7 IPv6头部结构"></a>2.7 IPv6头部结构</h3><pre><code>40字节固定头部 + 扩展头部</code></pre><p><img src="/2023/12/12/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B(%E4%B8%80)/image-6.png" alt="IPv6头部结构"></p><hr><h2 id="第三章-TCP协议详解"><a href="#第三章-TCP协议详解" class="headerlink" title="第三章 TCP协议详解"></a>第三章 TCP协议详解</h2><pre><code>和IP协议相比，TCP协议更靠近应用层，因此在应用程序中具有更强的可操作性。主要从以下四个方面来讨论TCP协议：    1.TCP头部信息：出现在每个TCP报文段中        作用：指定通信的源端端口号、目的端端口号，管理TCP连接，控制两个方向的数据流    2.TCP状态转移过程：TCP连接的任意一端都是一个状态机，TCP连接从建立到断开的整个过程中，两端的状态机都将经历不同的状态变迁。    3.TCP数据流：        （1）交互数据流        （2）成块数据流    TCP数据流中有一种特殊的数据：紧急数据    4.TCP数据流的控制：为了保证可靠传输和提高网络通信质量，内核需要对TCP数据流进行控制。        （1）超时重传        （2）拥塞控制</code></pre><h3 id="3-1-TCP服务的特点"><a href="#3-1-TCP服务的特点" class="headerlink" title="3.1 TCP服务的特点"></a>3.1 TCP服务的特点</h3><pre><code>传输层主要有两个协议：TCP协议   UDP协议TCP协议相对于UDP协议的特点是：面向连接、字节流和可靠传输1.使用TCP协议通信前提：    （1）双方必须先建立TCP连接，才能开始数据的读写。    （2）双方必须为连接分配必要的内核资源————管理连接状态、连接上的数据的传输。2.TCP连接是全双工的————双方的数据读写可以通过一条连接进行。3.完成通信后，双方必须都断开连接，以释放系统资源！注意：    TCP连接是一对一的，因此基于广播和多播的应用程序不能使用TCP服务，可以选择使用无连接协议UDP。</code></pre><h4 id="3-1-1-TCP协议面向字节流概念：应用程序对数据的发送和接受是没有边界限制的！"><a href="#3-1-1-TCP协议面向字节流概念：应用程序对数据的发送和接受是没有边界限制的！" class="headerlink" title="3.1.1 TCP协议面向字节流概念：应用程序对数据的发送和接受是没有边界限制的！"></a>3.1.1 TCP协议面向字节流概念：应用程序对数据的发送和接受是没有边界限制的！</h4><pre><code>发送端执行的写操作次数和接收端执行的读操作次数没有任何数量观念。（1）发送端原理：发送端连续执行多次写操作——&gt;TCP模块将这些数据放入到发送缓冲区——&gt;TCP模块真正开始发送数据时，将发送缓冲区的待发送数据封装成一个或多个TCP报文段发出（2）接收端原理：接收端收到一个或多个TCP报文段——&gt;按照TCP报文段序号放入到TCP接收缓冲区，并通知应用程序读取数据——&gt;应用程序根据接受缓冲区的大小，可以一次性全部读出数据，也可以分多次读取。</code></pre><h4 id="3-1-2-UDP协议面向数据报概念："><a href="#3-1-2-UDP协议面向数据报概念：" class="headerlink" title="3.1.2 UDP协议面向数据报概念："></a>3.1.2 UDP协议面向数据报概念：</h4><pre><code>发送端每写一个操作，UDP模块就将其封装成一个UDP数据报并发送之。接收端必须及时针对每一个数据报进行读操作，否则会丢包！并且，如果用户没有指定足够的应用程序缓冲区来读取UDP数据，则UDP数据将被截断！</code></pre><p><img src="/2023/12/12/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B(%E4%B8%80)/image-7.png" alt="TCP和UDP服务"></p><p>TCP传输是可靠的：</p><pre><code>（1）发送应答机制。发送端每发送一个TCP报文都必须得到接收端的应答，才认为传输成功。（2）超时重传机制。发送端发送一个TCP报文启动定时器，若定时器时间内未收到应答，将重新发送该报文。（3）由于IP数据报可能会乱序、重复，所以TCP协议会对接受到的TCP报文重排、整理，在交付给应用层。注意：UDP协议和IP协议一样，都是提供不可靠服务，需要上层协议处理数据确认和超时重传等。</code></pre><h3 id="3-2-TCP头部结构"><a href="#3-2-TCP头部结构" class="headerlink" title="3.2 TCP头部结构"></a>3.2 TCP头部结构</h3><pre><code>TCP头部结构：出现在每个TCP报文段中。    固定头部 + 头部选项    作用：指定通信源端端口、目的端端口、管理TCP连接等。</code></pre><h4 id="3-2-1-TCP固定头部结构"><a href="#3-2-1-TCP固定头部结构" class="headerlink" title="3.2.1 TCP固定头部结构"></a>3.2.1 TCP固定头部结构</h4><p><img src="/2023/12/12/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B(%E4%B8%80)/image-8.png" alt="TCP头部结构"></p><pre><code>1.16位源端口号、16位目的端口号：    告知主机该报文段来自哪里（源端口），以及要传输给哪个上层协议或者应用程序（目的端口）。2.32位序号：    一次TCP通信中的。某一个方向上的字节流的每个字节的编号。3.32位确认号：    对另一方发来的TCP报文段的响应。4.4位头部长度：用来标识TCP头部有多少个4字节。  TCP头部最长是60字节。5.6位标识为：    （1）URG：紧急指针是否有效    （2）ACK：确认号是否有效    （3）PSH：提示接收端立刻从接收缓冲区读数据，腾空间！    （4）RST：要求对方重新建立连接（复位报文段）    （5）SYN：请求建立一个连接（同步报文段）    （6）FIN：通知对方，本端要关闭连接了（结束报文段）6.16位窗口大小：是TCP流量控制的一个手段。告诉对方，本端的接受缓冲区还能容纳多少字节数据，这样对方可以控制发送数据的速度。7.16位校验和：由发送端填充，接收端通过CRC算法校验TCP报文段在传输过程是否损坏。    注意：不仅校验头部，也校验数据，这是TCP可靠传输的一个重要保障！8.16位紧急指针：TCP发送端向接收端发送紧急数据的方法。</code></pre><h4 id="3-2-2-TCP头部选项（40字节）"><a href="#3-2-2-TCP头部选项（40字节）" class="headerlink" title="3.2.2 TCP头部选项（40字节）"></a>3.2.2 TCP头部选项（40字节）</h4><pre><code>kind是选项类型、length是选项总长度、info是选项的具体信息</code></pre><p><img src="/2023/12/12/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B(%E4%B8%80)/image-9.png" alt="TCP头部选项的一般结构"></p><pre><code>TCP选项：</code></pre><p><img src="/2023/12/12/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B(%E4%B8%80)/image-10.png" alt="7种TCP选项"></p><pre><code>0：结束选项1：空操作，无特殊意义，一般用来将TCP选项的总长度填充为4字节的倍数。2：最大报文段长度3：窗口扩大因子：只能出现在同步报文段中，且同步报文段本身不执行窗口扩大操作。4：选择性确认：SACK技术——当出现报文段丢失时，TCP模块只重发丢失的TCP报文段。5：SACK实际工作：告诉发送方，本端已接受并缓存了不连续的数据块，让发送端据此检查并重发丢失的数据块8：时间戳：计算通信双方的回路时间，为TCP流量控制提供重要信息。</code></pre><h3 id="3-3-TCP连接的建立与关闭"><a href="#3-3-TCP连接的建立与关闭" class="headerlink" title="3.3 TCP连接的建立与关闭"></a>3.3 TCP连接的建立与关闭</h3><h4 id="3-3-1-三次握手-四次挥手"><a href="#3-3-1-三次握手-四次挥手" class="headerlink" title="3.3.1 三次握手 + 四次挥手"></a>3.3.1 三次握手 + 四次挥手</h4><p><img src="/2023/12/12/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B(%E4%B8%80)/image-11.png" alt="TCP连接的建立和关闭"></p><pre><code>三次握手：TCP连接建立    报文段1：客户端请求与服务器端建立连接    报文段2：服务器端同意建立连接，并确认请求（将客户端发来的报文的ISN序号 + 1 代表确认）    报文段3：客户端确认服务器端的同意（将服务器端发来的报文的ISN序号 + 1 代表确认）四次挥手：TCP连接关闭    报文段4：包含FIN标志，代表结束报文段，即客户端请求关闭连接    报文段5：确认客户端的关闭连接请求（由于报文段6也有对关闭连接请求的确认，所以实际可忽略此报文段）    报文段6：服务器端发送结束报文段，并确认客户端的关闭连接请求    报文段7：确认服务器端的结束报文段注意：由客户端先提出的关闭连接请求，因此客户端执行主动关闭，服务器端执行被动关闭</code></pre><h4 id="3-3-2-半关闭状态"><a href="#3-3-2-半关闭状态" class="headerlink" title="3.3.2 半关闭状态"></a>3.3.2 半关闭状态</h4><pre><code>通信的一方可以给对方发送结束报文段，以告知对方本端发送完毕，但依旧允许接收对方发来的数据，直到对方也发来结束报文段以关闭连接为止。</code></pre><h4 id="3-3-3-超时连接"><a href="#3-3-3-超时连接" class="headerlink" title="3.3.3 超时连接"></a>3.3.3 超时连接</h4><pre><code>原因：服务器相距很远或者服务器繁忙，导致服务器没有应答客户端发出的同步报文段。客户端行为：客户端尝试重连，多次重连无效后（次数取决于内核变量的定义），告知应用程序连接超时。</code></pre><h3 id="3-4-状态转移"><a href="#3-4-状态转移" class="headerlink" title="3.4 状态转移"></a>3.4 状态转移</h3><pre><code>TCP连接的任意一端在任一时刻都处于某种状态，使用netstat命令可以查看当前状态。</code></pre><h4 id="3-4-1-TCP状态转移总图"><a href="#3-4-1-TCP状态转移总图" class="headerlink" title="3.4.1 TCP状态转移总图"></a>3.4.1 TCP状态转移总图</h4><p><img src="/2023/12/12/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B(%E4%B8%80)/image-12.png" alt="TCP状态转移总图"></p><h4 id="3-4-2-TIME-WAIT状态"><a href="#3-4-2-TIME-WAIT状态" class="headerlink" title="3.4.2 TIME_WAIT状态"></a>3.4.2 TIME_WAIT状态</h4><pre><code>客户端在收到服务器发来的结束报文段后，并不会立刻进入CLOSED状态，而是要等待2MSL（报文段最大生存时间）才进入CLOSED，其中MSL建议值为2min，那么就是等待4min后才进入CLOSED状态。</code></pre><p>TIME_WAIT作用：</p><pre><code>1.可靠地终止TCP连接2.保证迟来的报文段有足够时间被识别和丢弃</code></pre><h3 id="3-5-复位报文段"><a href="#3-5-复位报文段" class="headerlink" title="3.5 复位报文段"></a>3.5 复位报文段</h3><p>产生复位报文段的三种情况：</p><pre><code>1.访问不存在端口（或者端口处于TIME_WAIT状态）2.异常终止连接：通过给对方发送一个复位报文段，可以以异常终止一个连接3.处理半打开连接：    服务器端由于故障重启，导致之前建立的连接失效，但是客户端依旧处于之前的TCP连接，此时客户端就处于半打开状态，而它所处于的这个连接就成为半打开连接，如果客户端向该半打开连接写入数据，将会收到一个复位报文段。</code></pre><h3 id="3-6-TCP交互数据流"><a href="#3-6-TCP交互数据流" class="headerlink" title="3.6 TCP交互数据流"></a>3.6 TCP交互数据流</h3><pre><code>TCP报文段所携带的应用程序数据：    1.交互数据：        特点：仅包含很少的字节，对实时性要求很高    2.成块数据        特点：通常为TCP报文段允许的最大数据长度，对传输效率要求高</code></pre><h4 id="3-6-1-延迟确认"><a href="#3-6-1-延迟确认" class="headerlink" title="3.6.1 延迟确认"></a>3.6.1 延迟确认</h4><pre><code>服务器不马上确认上次收到的数据，而是在一段延迟后查看本端是否有数据要发送，如果有，会将数据和对上次的确认一并发出。    作用：可以减少TCP报文的发送数量。</code></pre><h3 id="3-7-成块数据流"><a href="#3-7-成块数据流" class="headerlink" title="3.7 成块数据流"></a>3.7 成块数据流</h3><pre><code>一般是传输大文件。</code></pre><h3 id="3-8-带外数据"><a href="#3-8-带外数据" class="headerlink" title="3.8 带外数据"></a>3.8 带外数据</h3><pre><code>带外（OOB，Out Of Band）数据：用于迅速告知对方本端发生的重要事件，具有更高的优先级！</code></pre><p>UDP：</p><pre><code>没有实现带外数据传输。</code></pre><p>TCP:</p><pre><code>TCP利用头部的紧急指针标志和紧急指针，给应用程序提供了一种紧急方式，利用传输普通数据的连接传输紧急数据。这种紧急数据和带外数据类似，因此也将TCP紧急数据称为带外数据。</code></pre><h3 id="3-9-TCP超时重传"><a href="#3-9-TCP超时重传" class="headerlink" title="3.9 TCP超时重传"></a>3.9 TCP超时重传</h3><pre><code>TCP模块为每一个TCP报文段都维护一个重传定时器，该定时器在TCP报文段第一次被发送时启动。如果在定时器规定时间内没有收到对方的应答，将重传该报文段并重置定时器（时间由TCP重传策略决定，一般下一次时间将翻倍）</code></pre><p>注意：</p><pre><code>虽然超时会导致TCP报文段重传，但是重传也可以发生在超时之前，即快速重传。</code></pre><h3 id="3-10-拥塞控制"><a href="#3-10-拥塞控制" class="headerlink" title="3.10 拥塞控制"></a>3.10 拥塞控制</h3><pre><code>拥塞控制：提高网络利用率，降低丢包率，保证网络资源对每条数据流的公平性。包含四部分：慢启动、拥塞避免、快速重传、快速恢复</code></pre><p>专业名词：</p><pre><code>发送窗口（SWND）：限制发送端能连续发送TCP报文段的数量。接收窗口（RWND）：接收通告窗口，可以控制发送端的SWND，但显然不够，所以发送端引入了拥塞窗口。拥塞窗口（CWND）：发送窗口 = Min（拥塞窗口，接收窗口）</code></pre><p><img src="/2023/12/12/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B(%E4%B8%80)/image-13.png" alt="拥塞控制的输入和输出"></p><h4 id="3-10-1-慢启动和拥塞避免"><a href="#3-10-1-慢启动和拥塞避免" class="headerlink" title="3.10.1 慢启动和拥塞避免"></a>3.10.1 慢启动和拥塞避免</h4><p><img src="/2023/12/12/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B(%E4%B8%80)/image-15.png" alt="慢启动和拥塞避免"></p><p>慢启动：</p><pre><code>TCP模块刚开始并不知道网络的实际情况，所以需要一种试探的方式，来平滑的增大（以指数形式增大）CWND的大小。但是CWND不能无止境的增大，因此有一个慢启动门限，当CWND大小超过慢启动门限，则进入拥塞避免阶段。</code></pre><p>拥塞避免：</p><pre><code>使CWND按照线性方式增加，减缓其扩大。</code></pre><p>发送端判断拥塞发生时的依据：</p><pre><code>1.传输超时（重传定时器溢出）2.接收到重复的确认报文段</code></pre><h4 id="3-10-2-快速重传和快速恢复"><a href="#3-10-2-快速重传和快速恢复" class="headerlink" title="3.10.2 快速重传和快速恢复"></a>3.10.2 快速重传和快速恢复</h4><p>注意：</p><pre><code>很多情况下都会导致发送端收到重复的确认报文段，而不一定是由网络拥塞导致的，因此，如果发送端连续收到3个重复的确认报文段，则判定为网络拥塞，然后启用快速重传和快速恢复算法处理拥塞。</code></pre><p>快速重传：</p><pre><code>发送方连续收到三个重复的确认应答后，进行相应确实报文段的重传。</code></pre><p><img src="/2023/12/12/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B(%E4%B8%80)/image-16.png" alt="快速重传"></p><p>快速恢复：</p><pre><code>将慢开始门限更新为连续收到3次重复确认时的拥塞窗口的一半，然后更新拥塞窗口到该新的慢开始门限，直接执行拥塞避免算法。</code></pre><p><img src="/2023/12/12/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B(%E4%B8%80)/image-17.png" alt="快速恢复"></p><hr><h2 id="第四章-TCP-IP通信案例：访问internet上的服务器"><a href="#第四章-TCP-IP通信案例：访问internet上的服务器" class="headerlink" title="第四章 TCP&#x2F;IP通信案例：访问internet上的服务器"></a>第四章 TCP&#x2F;IP通信案例：访问internet上的服务器</h2><h3 id="4-1-实例总图"><a href="#4-1-实例总图" class="headerlink" title="4.1 实例总图"></a>4.1 实例总图</h3><p><img src="/2023/12/12/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B(%E4%B8%80)/image-18.png" alt="实例总图"></p><pre><code>HTTP协议：应用层的一种协议，默认使用的传输层协议是TCP</code></pre><h3 id="4-2-部署代理服务器"><a href="#4-2-部署代理服务器" class="headerlink" title="4.2 部署代理服务器"></a>4.2 部署代理服务器</h3><h4 id="4-2-1-HTTP代理服务器的工作原理"><a href="#4-2-1-HTTP代理服务器的工作原理" class="headerlink" title="4.2.1 HTTP代理服务器的工作原理"></a>4.2.1 HTTP代理服务器的工作原理</h4><p>说明：</p><pre><code>1.在HTTP通信链上，客户端和目标服务器之间通常存在某些中转代理服务器，它们提供对目标的中转访问。2.一个HTTP请求可能被多个代理服务器转发，后面服务器称为上游服务器。</code></pre><p>代理服务器：</p><pre><code>1.正向代理服务器：要求客户端自己设置代理服务器的地址，每次HTTP请求都直接由该代理服务器负责2.反向代理服务器：设置在服务端，用代理服务器接收Internet上的请求，然后转发给内部网络上的服务器。3.透明代理服务器：只能设置在网关上，可以看作是正向代理的一种特殊情况</code></pre><p><img src="/2023/12/12/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B(%E4%B8%80)/image-19.png" alt="代理服务器"></p><p>注意：</p><pre><code>IP头部的源端地址和目的端地址是始终不变的，而帧头部的源端物理地址和目的端物理地址则是一直变化的</code></pre><h3 id="4-4-访问DNS服务器"><a href="#4-4-访问DNS服务器" class="headerlink" title="4.4 访问DNS服务器"></a>4.4 访问DNS服务器</h3><pre><code>解析主机名的顺序：先访问本地 /etc/hosts，再访问DNS服务</code></pre><h3 id="4-6-HTTP通信"><a href="#4-6-HTTP通信" class="headerlink" title="4.6 HTTP通信"></a>4.6 HTTP通信</h3><p><img src="/2023/12/12/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B(%E4%B8%80)/image-20.png" alt="HTTP通信"></p><h4 id="4-6-1-HTTP请求"><a href="#4-6-1-HTTP请求" class="headerlink" title="4.6.1 HTTP请求"></a>4.6.1 HTTP请求</h4><pre><code>短链接：同一客户的多个连续HTTP请求不能共用同一个TCP连接长连接：多个请求可以使用同一个TCP连接，</code></pre><p>长连接的好处：</p><pre><code>极大减少了网络上建立TCP连接造成的符合，同时缩减了每个请求的处理时间。</code></pre><h4 id="4-6-2-HTTP应答"><a href="#4-6-2-HTTP应答" class="headerlink" title="4.6.2 HTTP应答"></a>4.6.2 HTTP应答</h4><pre><code>注意：HTTP协议是一种无状态协议，每个HTTP请求之间不存在任何上下文关系。如果服务器处理后续HTTP请求时需要用到前面的，那么客户端就必须重发一次前面的。</code></pre><p>Cookie</p><pre><code>保持HTTP连接状态的措施。</code></pre><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2023/12/12/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B(%E4%B8%80)/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.jpg&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
