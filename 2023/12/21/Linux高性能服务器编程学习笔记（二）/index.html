<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Linux高性能服务器编程学习笔记（二） | Mazd &#39; s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 7.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Mazd &#39; s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/categories">Categories</a>
        
          <a class="main-nav-link" href="/tags">Tags</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
      </nav>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Linux高性能服务器编程学习笔记（二）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/12/21/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2023-12-21T13:53:14.000Z" itemprop="datePublished">2023-12-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Linux高性能服务器编程学习笔记（二）
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
<p><img src="/2023/12/21/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.jpg"></p>
<span id="more"></span>

<h1 id="第二部分-深入解析高性能服务器编程（5-15章）"><a href="#第二部分-深入解析高性能服务器编程（5-15章）" class="headerlink" title="第二部分 深入解析高性能服务器编程（5~15章）"></a>第二部分 深入解析高性能服务器编程（5~15章）</h1><h2 id="第5章-网络编程基础API"><a href="#第5章-网络编程基础API" class="headerlink" title="第5章 网络编程基础API"></a>第5章 网络编程基础API</h2><p>从3个方面探讨： Linux网络编程基础API 与 内核中TCP&#x2F;IP协议族之间的关系</p>
<pre><code>1.socket地址API：socket最开始的含义是，一个IP地址和端口对，即（IP，port）。它唯一地表示了使用TCP通信的一端，称sokect地址。

2.socket基础API：定义在sys/sokect.h中，包括：创建sokect、命名sokect、监听sokect、接受连接、发起连接、读写数据、获取地址信息、检测带外标记、，以及读取和设置sokect选项。

3.网络信息API：定义在netdb.h中，实现主机名和IP地址之间的转换、服务名称和端口号之间的转换。
</code></pre>
<h3 id="5-1-sokect地址API"><a href="#5-1-sokect地址API" class="headerlink" title="5.1 sokect地址API"></a>5.1 sokect地址API</h3><h4 id="5-1-1-主机字节序和网络字节序"><a href="#5-1-1-主机字节序和网络字节序" class="headerlink" title="5.1.1 主机字节序和网络字节序"></a>5.1.1 主机字节序和网络字节序</h4><p>1.主机字节序</p>
<pre><code>字节序问题：4字节一个整数，这4个字节在内存中的排列顺序将影响它被累加器装在成的整数的值。

大端字节序（big endian）：高位字节存储在内存的低地址处，低位字节存储在内存的高地址处

小端字节序（little endian）：高位字节——&gt;内存高地址，低位字节——&gt;内存低地址
</code></pre>
<p>注意：现在PC大多采用小端字节序，因此小端字节序也称为主机字节序。</p>
<p>2.网络字节序</p>
<pre><code>发送端总要把发送的数据转换成大端字节序再发送，接收端根据自身采用的字节序决定是否需要转换字节序。因此大端字节序也称为网络字节序。

注意：同一台机器上的两个进程间的通信，也要考虑字节序的问题！
</code></pre>
<p>3.Linux提供了四个函数，完成主机字节序和网络字节序之间的转换：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="comment">//host to network long 将长整型主机字节序转换为网络字节序</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="title">hton</span><span class="params">( <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> hostlong )</span></span>; </span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="title">htons</span><span class="params">( <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> hostshort )</span></span>;</span><br><span class="line"><span class="comment">//network to host long 将长整型网络字节序转换为主机字节序</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="title">ntol</span><span class="params">( <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> netlong )</span></span>;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="title">ntohs</span><span class="params">( <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> netshort )</span></span>;</span><br></pre></td></tr></table></figure>
<pre><code>一般长整型函数用来转换IP地址，短整型函数一般用来转换端口号（当然不限于此，任何通过格式化的数据通过网络传输时都应该使用这些函数来转换字节序！）
</code></pre>
<h4 id="5-1-2-通用sokect地址"><a href="#5-1-2-通用sokect地址" class="headerlink" title="5.1.2 通用sokect地址"></a>5.1.2 通用sokect地址</h4><p>sokect网络编程接口中标识sokect地址的时结构体sockaddr：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr</span> &#123;</span><br><span class="line">    <span class="type">sa_family_t</span> sa_family;</span><br><span class="line">    <span class="type">char</span> sa_data[<span class="number">14</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>sa_family是地址族类型（sa_family_t）的变量，地址族通常与协议族对应。
sa_data成员用于存放sokect地址值。由于sa_data无法容纳多数的协议族地址值。所以linux定义了新的通用sokcet地址：
</code></pre>
<p>新的通用sokect地址：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个结构体不但提供了足够的内存空间存放地址值，而且是内存对齐的（__ss_align成员的作用！）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_storage</span>&#123;</span><br><span class="line">    <span class="type">sa_family_t</span> sa_family;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> __ss_align;</span><br><span class="line">    <span class="type">char</span> __ss_padding[<span class="number">128</span>-<span class="built_in">sizeof</span>(__ss_align )];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="5-1-3-专用sokect地址"><a href="#5-1-3-专用sokect地址" class="headerlink" title="5.1.3 专用sokect地址"></a>5.1.3 专用sokect地址</h4><pre><code>通用sokcet地址不好用，涉及繁琐的位操作，所以linux让各个协议族提供了专门的sokect地址结构体：
</code></pre>
<p>1.UNIX本地协议族：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_un</span> &#123;</span><br><span class="line">    <span class="type">sa_family_t</span> sin_family; <span class="comment">//地址族：AF_UNIX</span></span><br><span class="line">    <span class="type">char</span> sun_path[<span class="number">108</span>];     <span class="comment">//文件路径名</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2.TCP&#x2F;IP协议族有两个专用sokect地址结构体：IPv4和IPv6</p>
<p>IPv4：sockaddr_in</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> &#123;</span><br><span class="line">    <span class="type">sa_family_t</span> sin_family; <span class="comment">//地址族：AF_INET</span></span><br><span class="line">    <span class="type">u_int16_t</span> sin_port;     <span class="comment">//端口号：要用网络字节序表示</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> sin_addr;<span class="comment">//IPv4地址结构体</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span> &#123;</span><br><span class="line">    <span class="type">u_int32_t</span> s_addr;       <span class="comment">//IPv4地址，要用网络字节序表示</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IPv6：sockaddr_in6</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in6</span> &#123;</span><br><span class="line">    <span class="type">sa_family_t</span> sin6_family;    <span class="comment">//地址族：AF_INET6</span></span><br><span class="line">    <span class="type">u_int16_t</span> sin6_port;        <span class="comment">//端口号：要用网络字节序表示</span></span><br><span class="line">    <span class="type">u_int32_t</span> sin6_flowinfo;    <span class="comment">//流信息：应设置为0</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in6_addr</span> sin6_addr;  <span class="comment">//IPv6地址结构体</span></span><br><span class="line">    <span class="type">u_int32_t</span> sin6_scope_id;    <span class="comment">//scope ID，尚处于实验阶段</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in6_addr</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> sa_addr[<span class="number">16</span>];  <span class="comment">//IPv6地址：要用网络字节序表示</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：所有专用sokcet地址（以及sockaddr_storage）类型的变量，在实际使用时，都需要转化为通用sokect地址类型sockaddr（强制转换即可），因为所有sokcet编程接口使用的地址参数类型都是sockaddr。</p>
<h4 id="5-1-4-IP地址转化函数"><a href="#5-1-4-IP地址转化函数" class="headerlink" title="5.1.4 IP地址转化函数"></a>5.1.4 IP地址转化函数</h4><p>点分十进制字符串IPv4地址  与  网络字节序整数IPv4地址转换：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">//点分十进制IPv4——&gt;网络字节IPv4</span></span><br><span class="line"><span class="function"><span class="type">in_addr_t</span> <span class="title">inet_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* strptr)</span></span>;     </span><br><span class="line"><span class="comment">//与上面功能一样，但将转换结果存储在参数inp指向的地址结构体中</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">inet_aton</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* cp, strcut in_addr* inp)</span></span>; </span><br><span class="line"><span class="comment">//网络字节IPv4——&gt;点分十进制IPv4</span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr in)</span></span>;<span class="comment">//需要注意的是，该函数内部用一个静态变量存储转化结果，返回值指向静态内存</span></span><br></pre></td></tr></table></figure>
<p>下面这对更新的函数能够完成上述三个函数同样的功能，并且能适用于IPv4和IPv6：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#inclued<span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">//将字符串表示的IP地址src 转化成网络字节序表示的IP地址，并存储与dst指向的内存中</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span>* src, <span class="type">void</span>* dst)</span></span>;</span><br><span class="line"><span class="comment">//与上面转化相反，</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span>* src, <span class="type">char</span>* dst, <span class="type">socklen_t</span> cnt)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-2-创建socket"><a href="#5-2-创建socket" class="headerlink" title="5.2 创建socket"></a>5.2 创建socket</h3><pre><code>socket就是可读、可写、可控制、可关闭的文件描述符。
</code></pre>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure>
<pre><code>domain:使用哪个底层协议族，对于TCP/IP而言：PF_INET或者PF_INET6;对于UNIX本地域协议族而言，PF_UNIX;

type：指定服务类型。SOCK_STREAM(流服务)——TCP； SOCK_UGRAM(数据报服务)——UDP；

protocol:一般设置为0；
</code></pre>
<h3 id="5-3-命名socket"><a href="#5-3-命名socket" class="headerlink" title="5.3 命名socket"></a>5.3 命名socket</h3><p>未完待续..</p>
<hr>
<h2 id="第6章-高级I-O函数"><a href="#第6章-高级I-O函数" class="headerlink" title="第6章 高级I&#x2F;O函数"></a>第6章 高级I&#x2F;O函数</h2><p>大致分为三类：</p>
<pre><code>1.用于创建文件描述符的函数：包括pipe、dup/dup2函数
2.用于读写数据的函数：包括readv/writev/、sendfile、mmap/munmap、splice和tee函数
3.用于控制I/O行为和属性的函数，包括fcntl函数
</code></pre>
<h3 id="6-1-pipe函数"><a href="#6-1-pipe函数" class="headerlink" title="6.1 pipe函数"></a>6.1 pipe函数</h3><pre><code>作用：可用于创建一个管道，实现进程间通信。
</code></pre>
<p>定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pipe</span><span class="params">(<span class="type">int</span> fd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<pre><code>1.pipe函数的参数是，一个包含两个int整数的数组指针。

2.通过pipe函数创建的这两个文件描述符fd[0]和fd[1],分别构成了管道的两端。

3.fd[0]只能用于从管道读数据，fd[1]只能用于往管道写数据，而不能反过来使用。

4.如果要实现双向传输数据，则需要两个管道。

5.默认情况下，这两个文件描述符都是阻塞的。

6.如果用read读取一个空管道，则read将被阻塞；如果用write往一个满的管道写数据，write也将被阻塞。

7.可以使用fcntl函数修改管道容量
</code></pre>
<p>此外：</p>
<pre><code>socketpair函数：能够方便的创建双向管道：
</code></pre>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/tpyes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">socketpair</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> tpye, <span class="type">int</span> protocol, <span class="type">int</span> fd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="6-2-dup-函数和dup2-函数"><a href="#6-2-dup-函数和dup2-函数" class="headerlink" title="6.2 dup 函数和dup2 函数"></a>6.2 dup 函数和dup2 函数</h3><pre><code>作用：用于复制文件描述符
</code></pre>
<p>定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dup</span><span class="params">(<span class="type">int</span> file_descriptor)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dup2</span><span class="params">(<span class="type">int</span> file_descriptor_one, <span class="type">int</span> file_descriptor_two)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="6-3-readv-函数和writev-函数"><a href="#6-3-readv-函数和writev-函数" class="headerlink" title="6.3 readv 函数和writev 函数"></a>6.3 readv 函数和writev 函数</h3><pre><code>作用：
    readv函数将数据从文件描述符读到分散的内存块中，即分散读；
    writev函数将多块分散的内存块数据一并读到文件描述符，即集中写；
</code></pre>
<p>定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">readv</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec* vector, <span class="type">int</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">writev</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec* vector, <span class="type">int</span> count)</span></span>;</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<pre><code>fd是被操作的文件描述符；
vector参数的类型是iovec结构数组，该结构体描述一块内存区。
count是vector数组的长度，即有多少块内存需要从fd读出或写到fd。
</code></pre>
<h3 id="6-4-sendfile-函数"><a href="#6-4-sendfile-函数" class="headerlink" title="6.4 sendfile 函数"></a>6.4 sendfile 函数</h3><pre><code>作用：sendfile 函数在两个文件描述符之间直接传递数据（完全在内核中操作），从而避免了内核缓冲区和用户缓冲区，之间的数据拷贝，效率很高，这被称为零拷贝。
</code></pre>
<p>定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/sendfile.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">sendfile</span><span class="params">(<span class="type">int</span> out_fd, <span class="type">int</span> in_fd, <span class="type">off_t</span>* offset, <span class="type">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure>
<p>解释:</p>
<pre><code>in_fd待读出内容的文件描述符
out_fd是待写入内容的文件描述符
offset指定从读入文件流的哪个位置开始读，如果为空，则默认从起始位置。
count指定在in_fd和out_fd之间传输的字节数
</code></pre>
<h3 id="6-5-mmap-函数和-munmap函数"><a href="#6-5-mmap-函数和-munmap函数" class="headerlink" title="6.5 mmap 函数和 munmap函数"></a>6.5 mmap 函数和 munmap函数</h3><pre><code>作用：mmap函数用于申请一段内存空间，munmap函数则释放有mmap创建的这段内存空间。
</code></pre>
<p>定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/mmap.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">map</span><span class="params">(<span class="type">void</span>* start, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">munmap</span><span class="params">(<span class="type">void</span>* start, <span class="type">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<pre><code>start：允许用于将某个特定地址作为这段内存的起始地址
length：指定这段内存的长度
prot：设置这段内存的访问权限：PROT_READ,内存段可读；PROT_WRITE,内存段可写；PROT_EXEC,可执行；PROT_NONE,不可访问
flags：控制内存段被修改后程序的行为
fd：指被映射文件对应的文件描述符，一般通过open系统调用获得
offset：设置从文件的何处开始映射
</code></pre>
<h3 id="6-6-splice-函数"><a href="#6-6-splice-函数" class="headerlink" title="6.6 splice 函数"></a>6.6 splice 函数</h3><pre><code>作用：用于在两个文件描述符之间移动数据，也是零拷贝操作。
</code></pre>
<p>定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">splice</span><span class="params">(<span class="type">int</span> fd_in, <span class="type">loff_t</span>* offin, <span class="type">int</span> fd_out, <span class="type">loff_t</span>* off_out, <span class="type">size_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<pre><code>fd_in：待输入数据的文件描述符
offin：若fd_in是管道文件描述符，则必须设置为NULL；反之，表示从输入流的何处开始读取数据
len：指定移动数据的长度
flags：控制数据如何移动
</code></pre>
<p>使用splice函数时，fd_in和fd_out必须至少有一个是管道文件描述符。</p>
<h3 id="6-7-tee-函数"><a href="#6-7-tee-函数" class="headerlink" title="6.7 tee 函数"></a>6.7 tee 函数</h3><pre><code>作用：在两个管道文件描述符之间复制数据，也是零拷贝操作。
</code></pre>
<p>定义:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">tee</span><span class="params">(<span class="type">int</span> fd_in, <span class="type">int</span> fd_out, <span class="type">size_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<pre><code>fd_in和fd_out都必须是管道文件描述符
</code></pre>
<h3 id="6-8-fcntl-函数"><a href="#6-8-fcntl-函数" class="headerlink" title="6.8 fcntl 函数"></a>6.8 fcntl 函数</h3><pre><code>作用：提供了对文件描述符的各种控制操作
</code></pre>
<p>定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<pre><code>fd：被操作的文件描述符
cmd：指定执行何种类型的操作，根据类型不同，可能还需第三个参数arg
</code></pre>
<p>在网络编程中，fcntl函数通常用来将一个文件描述符设置为非阻塞的。</p>
<hr>
<h2 id="第7章-Linux服务器程序规范"><a href="#第7章-Linux服务器程序规范" class="headerlink" title="第7章 Linux服务器程序规范"></a>第7章 Linux服务器程序规范</h2><pre><code>服务器程序的一些主要规范：日志、PID文件、系统资源占用、配置文件等等。。。
</code></pre>
<h3 id="7-1-日志"><a href="#7-1-日志" class="headerlink" title="7.1 日志"></a>7.1 日志</h3><h4 id="7-1-1-Linux系统日志"><a href="#7-1-1-Linux系统日志" class="headerlink" title="7.1.1 Linux系统日志"></a>7.1.1 Linux系统日志</h4><pre><code>rsyslogd守护进程：既能接收用户进程输出的日志，又能接收内核日志。
</code></pre>
<h4 id="7-1-2-syslog-函数"><a href="#7-1-2-syslog-函数" class="headerlink" title="7.1.2 syslog 函数"></a>7.1.2 syslog 函数</h4><pre><code>作用：应用程序使用syslog函数与rsyslogd守护进程通信。
</code></pre>
<p>定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="function">viud <span class="title">stslog</span><span class="params">(<span class="type">int</span> priority, <span class="type">const</span> <span class="type">char</span>* message, ...)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="7-2-用户信息"><a href="#7-2-用户信息" class="headerlink" title="7.2 用户信息"></a>7.2 用户信息</h3><h4 id="7-2-1-UID、EUID、GID、EGID"><a href="#7-2-1-UID、EUID、GID、EGID" class="headerlink" title="7.2.1 UID、EUID、GID、EGID"></a>7.2.1 UID、EUID、GID、EGID</h4><pre><code>UID:真实用户ID
EUID:有效用户ID
GID:真实组ID
EGID:有效组ID
</code></pre>
<p>函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/tpyes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">uid_t</span> <span class="title">getuid</span><span class="params">()</span></span>;         <span class="comment">//获取真是用户id</span></span><br><span class="line"><span class="function"><span class="type">uid_t</span> <span class="title">geteuid</span><span class="params">()</span></span>;        <span class="comment">//获取有效用户id</span></span><br><span class="line"><span class="function"><span class="type">gid_t</span> <span class="title">getgid</span><span class="params">()</span></span>;         <span class="comment">//获取真实组id</span></span><br><span class="line"><span class="function"><span class="type">gid_t</span> <span class="title">getegid</span><span class="params">()</span></span>;        <span class="comment">//获取有效组id</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setuid</span><span class="params">(<span class="type">uid_t</span> uid)</span></span>;  <span class="comment">//设置真是用户id</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">seteuid</span><span class="params">(<span class="type">uid_t</span> uid)</span></span>; <span class="comment">//设置有效用户id</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setgid</span><span class="params">(<span class="type">gid_t</span> gid)</span></span>;  <span class="comment">//设置真实组id</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">segegid</span><span class="params">(<span class="type">gid_t</span> gid)</span></span>; <span class="comment">//设置有效组id</span></span><br></pre></td></tr></table></figure>
<p>需要指出的是：</p>
<pre><code>一个进程拥有两个用户ID：UID和EUID。 EUID存在的目的是方便资源访问。
</code></pre>
<h4 id="7-2-2-用户切换"><a href="#7-2-2-用户切换" class="headerlink" title="7.2.2 用户切换"></a>7.2.2 用户切换</h4><h3 id="7-3-进程间关系"><a href="#7-3-进程间关系" class="headerlink" title="7.3 进程间关系"></a>7.3 进程间关系</h3><h4 id="7-3-1-进程组"><a href="#7-3-1-进程组" class="headerlink" title="7.3.1 进程组"></a>7.3.1 进程组</h4><pre><code>Linux下每个进程都隶属于一个进程组，因此它们除了PID信息外，还有进程组ID（PGID）。
</code></pre>
<p>通过以下函数获取指定进程的PGID：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">getpgid</span><span class="params">(<span class="type">pit_t</span> pid)</span></span>;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<pre><code>1.每个进程组都有一个首领进程，其PGID和PID相同。
2.进程组将一直存在，直到其中所有进程都推出，或加入到其他进程组。
</code></pre>
<p>通过以下函数设置PGID：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">//该函数将PID为pid的进程的PGID设置为pgid</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setpgid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid)</span></span>;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<pre><code>1.一个进程只能设置自己或者其子进程的PGID
2.当子进程调用exec系列函数后，不能再在父进程中对它设置PGID
</code></pre>
<h4 id="7-3-2-会话"><a href="#7-3-2-会话" class="headerlink" title="7.3.2 会话"></a>7.3.2 会话</h4><pre><code>一些有关联的进程组将形成一个会话（session）
</code></pre>
<p>创建会话：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">setsid</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<pre><code>该函数不能由进程组的首领进程调用。
</code></pre>
<p>获取会话ID：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">getsid</span><span class="params">(<span class="type">pid_t</span> pid)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="7-3-3-用ps命令查看进程关系"><a href="#7-3-3-用ps命令查看进程关系" class="headerlink" title="7.3.3 用ps命令查看进程关系"></a>7.3.3 用ps命令查看进程关系</h4><h3 id="7-4-系统资源限制"><a href="#7-4-系统资源限制" class="headerlink" title="7.4 系统资源限制"></a>7.4 系统资源限制</h3><p>Linux系统资源限制通过如下一对函数进行读取和设置：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getrlimit</span><span class="params">(<span class="type">int</span> resource, <span class="keyword">struct</span> rlimit* rlim)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setrlimit</span><span class="params">(<span class="type">int</span> resource, <span class="type">const</span> <span class="keyword">struct</span> rlimit* rlim)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">rlimit</span> &#123;</span><br><span class="line">    <span class="type">rlim_t</span> rlim_cur;</span><br><span class="line">    <span class="type">rlim_t</span> rlim_max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="7-5-改变工作目录和根目录"><a href="#7-5-改变工作目录和根目录" class="headerlink" title="7.5 改变工作目录和根目录"></a>7.5 改变工作目录和根目录</h3><p>获取进程当前工作目录、改变进程工作目录：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">getcwd</span><span class="params">(<span class="type">char</span>* buf, <span class="type">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cndir</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path)</span></span>;</span><br></pre></td></tr></table></figure>
<p>改变进程根目录：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">chroot</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="7-6-服务器程序后台化"><a href="#7-6-服务器程序后台化" class="headerlink" title="7.6 服务器程序后台化"></a>7.6 服务器程序后台化</h3><pre><code>讨论如何在代码中，让一个进程以守护进程的方式运行。
</code></pre>
<p>Linux提供的库函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">daemon</span> <span class="params">(<span class="type">int</span> nochdir, <span class="type">int</span> noclose)</span></span>;</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<pre><code>nochdir：用于指定是否改变工作目录，如果传递0，则工作目录将被设置为“/”根目录，否则继续使用当前工作目录。
noclose：为0时，标准输入、标准输出和标准错误输出都被重定向到/dev/null文件，否则依然使用原来的设备。
</code></pre>
<hr>
<h2 id="第8章-高性能服务器程序框架"><a href="#第8章-高性能服务器程序框架" class="headerlink" title="第8章 高性能服务器程序框架"></a>第8章 高性能服务器程序框架</h2><p>将服务器解构为如下三个主要模块：</p>
<pre><code>1.I/O处理单元。
2.逻辑单元。
3.存储单元。
</code></pre>
<h3 id="8-1-服务器模型"><a href="#8-1-服务器模型" class="headerlink" title="8.1 服务器模型"></a>8.1 服务器模型</h3><h4 id="8-1-1-C-S模型"><a href="#8-1-1-C-S模型" class="headerlink" title="8.1.1 C&#x2F;S模型"></a>8.1.1 C&#x2F;S模型</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/12/21/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/" data-id="clt5m4veh00019sv8efpjh0o2" data-title="Linux高性能服务器编程学习笔记（二）" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2024/02/26/C-11%E5%B8%B8%E7%94%A8%E7%89%B9%E6%80%A7/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前一篇</strong>
      <div class="article-nav-title">
        
          C++11常用特性
        
      </div>
    </a>
  
  
    <a href="/2023/12/12/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B(%E4%B8%80)/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">Linus高性能服务器编程学习笔记（一）</div>
    </a>
  
</nav>

  
</article>


</section>
        <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-11/" rel="tag">C++11</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/STL/" rel="tag">STL</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/02/28/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">十大排序算法</a>
          </li>
        
          <li>
            <a href="/2024/02/26/%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93STL/">标准模板库STL</a>
          </li>
        
          <li>
            <a href="/2024/02/26/C-11%E5%B8%B8%E7%94%A8%E7%89%B9%E6%80%A7/">C++11常用特性</a>
          </li>
        
          <li>
            <a href="/2023/12/21/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/">Linux高性能服务器编程学习笔记（二）</a>
          </li>
        
          <li>
            <a href="/2023/12/12/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B(%E4%B8%80)/">Linus高性能服务器编程学习笔记（一）</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/02/">二月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">十二月 2023</a></li></ul>
    </div>
  </div>

  
</aside>
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2024 By Autoload<br>
      Driven - <a href="https://hexo.io/" target="_blank">Hexo</a>|Theme - <a href="https://github.com/autoload/hexo-theme-auto" target="_blank">Auto</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>


<script src="/js/script.js"></script>




  </div>
</body>
</html>