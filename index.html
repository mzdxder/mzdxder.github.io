<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Mazd &#39; s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 7.0.0"><script src="/assets/js/DPlayer.min.js"></script></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Mazd &#39; s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/categories">Categories</a>
        
          <a class="main-nav-link" href="/tags">Tags</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
      </nav>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Linux高性能服务器编程学习笔记（二）" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/12/21/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/" class="article-date">
  <time class="dt-published" datetime="2023-12-21T13:53:14.000Z" itemprop="datePublished">2023-12-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/12/21/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/">Linux高性能服务器编程学习笔记（二）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="第二部分-深入解析高性能服务器编程（5-15章）"><a href="#第二部分-深入解析高性能服务器编程（5-15章）" class="headerlink" title="第二部分 深入解析高性能服务器编程（5~15章）"></a>第二部分 深入解析高性能服务器编程（5~15章）</h1><h2 id="第5章-网络编程基础API"><a href="#第5章-网络编程基础API" class="headerlink" title="第5章 网络编程基础API"></a>第5章 网络编程基础API</h2><p>从3个方面探讨： Linux网络编程基础API 与 内核中TCP&#x2F;IP协议族之间的关系</p>
<pre><code>1.socket地址API：socket最开始的含义是，一个IP地址和端口对，即（IP，port）。它唯一地表示了使用TCP通信的一端，称sokect地址。

2.socket基础API：定义在sys/sokect.h中，包括：创建sokect、命名sokect、监听sokect、接受连接、发起连接、读写数据、获取地址信息、检测带外标记、，以及读取和设置sokect选项。

3.网络信息API：定义在netdb.h中，实现主机名和IP地址之间的转换、服务名称和端口号之间的转换。
</code></pre>
<h3 id="5-1-sokect地址API"><a href="#5-1-sokect地址API" class="headerlink" title="5.1 sokect地址API"></a>5.1 sokect地址API</h3><h4 id="5-1-1-主机字节序和网络字节序"><a href="#5-1-1-主机字节序和网络字节序" class="headerlink" title="5.1.1 主机字节序和网络字节序"></a>5.1.1 主机字节序和网络字节序</h4><p>1.主机字节序</p>
<pre><code>字节序问题：4字节一个整数，这4个字节在内存中的排列顺序将影响它被累加器装在成的整数的值。

大端字节序（big endian）：高位字节存储在内存的低地址处，低位字节存储在内存的高地址处

小端字节序（little endian）：高位字节——&gt;内存高地址，低位字节——&gt;内存低地址
</code></pre>
<p>注意：现在PC大多采用小端字节序，因此小端字节序也称为主机字节序。</p>
<p>2.网络字节序</p>
<pre><code>发送端总要把发送的数据转换成大端字节序再发送，接收端根据自身采用的字节序决定是否需要转换字节序。因此大端字节序也称为网络字节序。

注意：同一台机器上的两个进程间的通信，也要考虑字节序的问题！
</code></pre>
<p>3.Linux提供了四个函数，完成主机字节序和网络字节序之间的转换：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="comment">//host to network long 将长整型主机字节序转换为网络字节序</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="title">hton</span><span class="params">( <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> hostlong )</span></span>; </span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="title">htons</span><span class="params">( <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> hostshort )</span></span>;</span><br><span class="line"><span class="comment">//network to host long 将长整型网络字节序转换为主机字节序</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="title">ntol</span><span class="params">( <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> netlong )</span></span>;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="title">ntohs</span><span class="params">( <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> netshort )</span></span>;</span><br></pre></td></tr></table></figure>
<pre><code>一般长整型函数用来转换IP地址，短整型函数一般用来转换端口号（当然不限于此，任何通过格式化的数据通过网络传输时都应该使用这些函数来转换字节序！）
</code></pre>
<h4 id="5-1-2-通用sokect地址"><a href="#5-1-2-通用sokect地址" class="headerlink" title="5.1.2 通用sokect地址"></a>5.1.2 通用sokect地址</h4><p>sokect网络编程接口中标识sokect地址的时结构体sockaddr：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr</span> &#123;</span><br><span class="line">    <span class="type">sa_family_t</span> sa_family;</span><br><span class="line">    <span class="type">char</span> sa_data[<span class="number">14</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>sa_family是地址族类型（sa_family_t）的变量，地址族通常与协议族对应。
sa_data成员用于存放sokect地址值。由于sa_data无法容纳多数的协议族地址值。所以linux定义了新的通用sokcet地址：
</code></pre>
<p>新的通用sokect地址：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个结构体不但提供了足够的内存空间存放地址值，而且是内存对齐的（__ss_align成员的作用！）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_storage</span>&#123;</span><br><span class="line">    <span class="type">sa_family_t</span> sa_family;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> __ss_align;</span><br><span class="line">    <span class="type">char</span> __ss_padding[<span class="number">128</span>-<span class="built_in">sizeof</span>(__ss_align )];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="5-1-3-专用sokect地址"><a href="#5-1-3-专用sokect地址" class="headerlink" title="5.1.3 专用sokect地址"></a>5.1.3 专用sokect地址</h4><pre><code>通用sokcet地址不好用，涉及繁琐的位操作，所以linux让各个协议族提供了专门的sokect地址结构体：
</code></pre>
<p>1.UNIX本地协议族：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_un</span> &#123;</span><br><span class="line">    <span class="type">sa_family_t</span> sin_family; <span class="comment">//地址族：AF_UNIX</span></span><br><span class="line">    <span class="type">char</span> sun_path[<span class="number">108</span>];     <span class="comment">//文件路径名</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2.TCP&#x2F;IP协议族有两个专用sokect地址结构体：IPv4和IPv6</p>
<p>IPv4：sockaddr_in</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> &#123;</span><br><span class="line">    <span class="type">sa_family_t</span> sin_family; <span class="comment">//地址族：AF_INET</span></span><br><span class="line">    <span class="type">u_int16_t</span> sin_port;     <span class="comment">//端口号：要用网络字节序表示</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> sin_addr;<span class="comment">//IPv4地址结构体</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span> &#123;</span><br><span class="line">    <span class="type">u_int32_t</span> s_addr;       <span class="comment">//IPv4地址，要用网络字节序表示</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IPv6：sockaddr_in6</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in6</span> &#123;</span><br><span class="line">    <span class="type">sa_family_t</span> sin6_family;    <span class="comment">//地址族：AF_INET6</span></span><br><span class="line">    <span class="type">u_int16_t</span> sin6_port;        <span class="comment">//端口号：要用网络字节序表示</span></span><br><span class="line">    <span class="type">u_int32_t</span> sin6_flowinfo;    <span class="comment">//流信息：应设置为0</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in6_addr</span> sin6_addr;  <span class="comment">//IPv6地址结构体</span></span><br><span class="line">    <span class="type">u_int32_t</span> sin6_scope_id;    <span class="comment">//scope ID，尚处于实验阶段</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in6_addr</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> sa_addr[<span class="number">16</span>];  <span class="comment">//IPv6地址：要用网络字节序表示</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：所有专用sokcet地址（以及sockaddr_storage）类型的变量，在实际使用时，都需要转化为通用sokect地址类型sockaddr（强制转换即可），因为所有sokcet编程接口使用的地址参数类型都是sockaddr。</p>
<h4 id="5-1-4-IP地址转化函数"><a href="#5-1-4-IP地址转化函数" class="headerlink" title="5.1.4 IP地址转化函数"></a>5.1.4 IP地址转化函数</h4><p>点分十进制字符串IPv4地址  与  网络字节序整数IPv4地址转换：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">//点分十进制IPv4——&gt;网络字节IPv4</span></span><br><span class="line"><span class="function"><span class="type">in_addr_t</span> <span class="title">inet_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* strptr)</span></span>;     </span><br><span class="line"><span class="comment">//与上面功能一样，但将转换结果存储在参数inp指向的地址结构体中</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">inet_aton</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* cp, strcut in_addr* inp)</span></span>; </span><br><span class="line"><span class="comment">//网络字节IPv4——&gt;点分十进制IPv4</span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr in)</span></span>;<span class="comment">//需要注意的是，该函数内部用一个静态变量存储转化结果，返回值指向静态内存</span></span><br></pre></td></tr></table></figure>
<p>下面这对更新的函数能够完成上述三个函数同样的功能，并且能适用于IPv4和IPv6：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#inclued<span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">//将字符串表示的IP地址src 转化成网络字节序表示的IP地址，并存储与dst指向的内存中</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span>* src, <span class="type">void</span>* dst)</span></span>;</span><br><span class="line"><span class="comment">//与上面转化相反，</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span>* src, <span class="type">char</span>* dst, <span class="type">socklen_t</span> cnt)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="5-2-创建socket"><a href="#5-2-创建socket" class="headerlink" title="5.2 创建socket"></a>5.2 创建socket</h3><pre><code>socket就是可读、可写、可控制、可关闭的文件描述符。
</code></pre>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure>
<pre><code>domain:使用哪个底层协议族，对于TCP/IP而言：PF_INET或者PF_INET6;对于UNIX本地域协议族而言，PF_UNIX;

type：指定服务类型。SOCK_STREAM(流服务)——TCP； SOCK_UGRAM(数据报服务)——UDP；

protocol:一般设置为0；
</code></pre>
<h3 id="5-3-命名socket"><a href="#5-3-命名socket" class="headerlink" title="5.3 命名socket"></a>5.3 命名socket</h3><p>未完待续..</p>
<hr>
<h2 id="第6章-高级I-O函数"><a href="#第6章-高级I-O函数" class="headerlink" title="第6章 高级I&#x2F;O函数"></a>第6章 高级I&#x2F;O函数</h2><p>大致分为三类：</p>
<pre><code>1.用于创建文件描述符的函数：包括pipe、dup/dup2函数
2.用于读写数据的函数：包括readv/writev/、sendfile、mmap/munmap、splice和tee函数
3.用于控制I/O行为和属性的函数，包括fcntl函数
</code></pre>
<h3 id="6-1-pipe函数"><a href="#6-1-pipe函数" class="headerlink" title="6.1 pipe函数"></a>6.1 pipe函数</h3><pre><code>作用：可用于创建一个管道，实现进程间通信。
</code></pre>
<p>定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pipe</span><span class="params">(<span class="type">int</span> fd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<pre><code>1.pipe函数的参数是，一个包含两个int整数的数组指针。

2.通过pipe函数创建的这两个文件描述符fd[0]和fd[1],分别构成了管道的两端。

3.fd[0]只能用于从管道读数据，fd[1]只能用于往管道写数据，而不能反过来使用。

4.如果要实现双向传输数据，则需要两个管道。

5.默认情况下，这两个文件描述符都是阻塞的。

6.如果用read读取一个空管道，则read将被阻塞；如果用write往一个满的管道写数据，write也将被阻塞。

7.可以使用fcntl函数修改管道容量
</code></pre>
<p>此外：</p>
<pre><code>socketpair函数：能够方便的创建双向管道：
</code></pre>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/tpyes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">socketpair</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> tpye, <span class="type">int</span> protocol, <span class="type">int</span> fd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="6-2-dup-函数和dup2-函数"><a href="#6-2-dup-函数和dup2-函数" class="headerlink" title="6.2 dup 函数和dup2 函数"></a>6.2 dup 函数和dup2 函数</h3><pre><code>作用：用于复制文件描述符
</code></pre>
<p>定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dup</span><span class="params">(<span class="type">int</span> file_descriptor)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dup2</span><span class="params">(<span class="type">int</span> file_descriptor_one, <span class="type">int</span> file_descriptor_two)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="6-3-readv-函数和writev-函数"><a href="#6-3-readv-函数和writev-函数" class="headerlink" title="6.3 readv 函数和writev 函数"></a>6.3 readv 函数和writev 函数</h3><pre><code>作用：
    readv函数将数据从文件描述符读到分散的内存块中，即分散读；
    writev函数将多块分散的内存块数据一并读到文件描述符，即集中写；
</code></pre>
<p>定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">readv</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec* vector, <span class="type">int</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">writev</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec* vector, <span class="type">int</span> count)</span></span>;</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<pre><code>fd是被操作的文件描述符；
vector参数的类型是iovec结构数组，该结构体描述一块内存区。
count是vector数组的长度，即有多少块内存需要从fd读出或写到fd。
</code></pre>
<h3 id="6-4-sendfile-函数"><a href="#6-4-sendfile-函数" class="headerlink" title="6.4 sendfile 函数"></a>6.4 sendfile 函数</h3><pre><code>作用：sendfile 函数在两个文件描述符之间直接传递数据（完全在内核中操作），从而避免了内核缓冲区和用户缓冲区，之间的数据拷贝，效率很高，这被称为零拷贝。
</code></pre>
<p>定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/sendfile.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">sendfile</span><span class="params">(<span class="type">int</span> out_fd, <span class="type">int</span> in_fd, <span class="type">off_t</span>* offset, <span class="type">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure>
<p>解释:</p>
<pre><code>in_fd待读出内容的文件描述符
out_fd是待写入内容的文件描述符
offset指定从读入文件流的哪个位置开始读，如果为空，则默认从起始位置。
count指定在in_fd和out_fd之间传输的字节数
</code></pre>
<h3 id="6-5-mmap-函数和-munmap函数"><a href="#6-5-mmap-函数和-munmap函数" class="headerlink" title="6.5 mmap 函数和 munmap函数"></a>6.5 mmap 函数和 munmap函数</h3><pre><code>作用：mmap函数用于申请一段内存空间，munmap函数则释放有mmap创建的这段内存空间。
</code></pre>
<p>定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/mmap.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">map</span><span class="params">(<span class="type">void</span>* start, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">munmap</span><span class="params">(<span class="type">void</span>* start, <span class="type">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<pre><code>start：允许用于将某个特定地址作为这段内存的起始地址
length：指定这段内存的长度
prot：设置这段内存的访问权限：PROT_READ,内存段可读；PROT_WRITE,内存段可写；PROT_EXEC,可执行；PROT_NONE,不可访问
flags：控制内存段被修改后程序的行为
fd：指被映射文件对应的文件描述符，一般通过open系统调用获得
offset：设置从文件的何处开始映射
</code></pre>
<h3 id="6-6-splice-函数"><a href="#6-6-splice-函数" class="headerlink" title="6.6 splice 函数"></a>6.6 splice 函数</h3><pre><code>作用：用于在两个文件描述符之间移动数据，也是零拷贝操作。
</code></pre>
<p>定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">splice</span><span class="params">(<span class="type">int</span> fd_in, <span class="type">loff_t</span>* offin, <span class="type">int</span> fd_out, <span class="type">loff_t</span>* off_out, <span class="type">size_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<pre><code>fd_in：待输入数据的文件描述符
offin：若fd_in是管道文件描述符，则必须设置为NULL；反之，表示从输入流的何处开始读取数据
len：指定移动数据的长度
flags：控制数据如何移动
</code></pre>
<p>使用splice函数时，fd_in和fd_out必须至少有一个是管道文件描述符。</p>
<h3 id="6-7-tee-函数"><a href="#6-7-tee-函数" class="headerlink" title="6.7 tee 函数"></a>6.7 tee 函数</h3><pre><code>作用：在两个管道文件描述符之间复制数据，也是零拷贝操作。
</code></pre>
<p>定义:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">tee</span><span class="params">(<span class="type">int</span> fd_in, <span class="type">int</span> fd_out, <span class="type">size_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<pre><code>fd_in和fd_out都必须是管道文件描述符
</code></pre>
<h3 id="6-8-fcntl-函数"><a href="#6-8-fcntl-函数" class="headerlink" title="6.8 fcntl 函数"></a>6.8 fcntl 函数</h3><pre><code>作用：提供了对文件描述符的各种控制操作
</code></pre>
<p>定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<pre><code>fd：被操作的文件描述符
cmd：指定执行何种类型的操作，根据类型不同，可能还需第三个参数arg
</code></pre>
<p>在网络编程中，fcntl函数通常用来将一个文件描述符设置为非阻塞的。</p>
<hr>
<h2 id="第7章-Linux服务器程序规范"><a href="#第7章-Linux服务器程序规范" class="headerlink" title="第7章 Linux服务器程序规范"></a>第7章 Linux服务器程序规范</h2><pre><code>服务器程序的一些主要规范：日志、PID文件、系统资源占用、配置文件等等。。。
</code></pre>
<h3 id="7-1-日志"><a href="#7-1-日志" class="headerlink" title="7.1 日志"></a>7.1 日志</h3><h4 id="7-1-1-Linux系统日志"><a href="#7-1-1-Linux系统日志" class="headerlink" title="7.1.1 Linux系统日志"></a>7.1.1 Linux系统日志</h4><pre><code>rsyslogd守护进程：既能接收用户进程输出的日志，又能接收内核日志。
</code></pre>
<h4 id="7-1-2-syslog-函数"><a href="#7-1-2-syslog-函数" class="headerlink" title="7.1.2 syslog 函数"></a>7.1.2 syslog 函数</h4><pre><code>作用：应用程序使用syslog函数与rsyslogd守护进程通信。
</code></pre>
<p>定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="function">viud <span class="title">stslog</span><span class="params">(<span class="type">int</span> priority, <span class="type">const</span> <span class="type">char</span>* message, ...)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="7-2-用户信息"><a href="#7-2-用户信息" class="headerlink" title="7.2 用户信息"></a>7.2 用户信息</h3><h4 id="7-2-1-UID、EUID、GID、EGID"><a href="#7-2-1-UID、EUID、GID、EGID" class="headerlink" title="7.2.1 UID、EUID、GID、EGID"></a>7.2.1 UID、EUID、GID、EGID</h4><pre><code>UID:真实用户ID
EUID:有效用户ID
GID:真实组ID
EGID:有效组ID
</code></pre>
<p>函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/tpyes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">uid_t</span> <span class="title">getuid</span><span class="params">()</span></span>;         <span class="comment">//获取真是用户id</span></span><br><span class="line"><span class="function"><span class="type">uid_t</span> <span class="title">geteuid</span><span class="params">()</span></span>;        <span class="comment">//获取有效用户id</span></span><br><span class="line"><span class="function"><span class="type">gid_t</span> <span class="title">getgid</span><span class="params">()</span></span>;         <span class="comment">//获取真实组id</span></span><br><span class="line"><span class="function"><span class="type">gid_t</span> <span class="title">getegid</span><span class="params">()</span></span>;        <span class="comment">//获取有效组id</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setuid</span><span class="params">(<span class="type">uid_t</span> uid)</span></span>;  <span class="comment">//设置真是用户id</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">seteuid</span><span class="params">(<span class="type">uid_t</span> uid)</span></span>; <span class="comment">//设置有效用户id</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setgid</span><span class="params">(<span class="type">gid_t</span> gid)</span></span>;  <span class="comment">//设置真实组id</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">segegid</span><span class="params">(<span class="type">gid_t</span> gid)</span></span>; <span class="comment">//设置有效组id</span></span><br></pre></td></tr></table></figure>
<p>需要指出的是：</p>
<pre><code>一个进程拥有两个用户ID：UID和EUID。 EUID存在的目的是方便资源访问。
</code></pre>
<h4 id="7-2-2-用户切换"><a href="#7-2-2-用户切换" class="headerlink" title="7.2.2 用户切换"></a>7.2.2 用户切换</h4><h3 id="7-3-进程间关系"><a href="#7-3-进程间关系" class="headerlink" title="7.3 进程间关系"></a>7.3 进程间关系</h3><h4 id="7-3-1-进程组"><a href="#7-3-1-进程组" class="headerlink" title="7.3.1 进程组"></a>7.3.1 进程组</h4><pre><code>Linux下每个进程都隶属于一个进程组，因此它们除了PID信息外，还有进程组ID（PGID）。
</code></pre>
<p>通过以下函数获取指定进程的PGID：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">getpgid</span><span class="params">(<span class="type">pit_t</span> pid)</span></span>;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<pre><code>1.每个进程组都有一个首领进程，其PGID和PID相同。
2.进程组将一直存在，直到其中所有进程都推出，或加入到其他进程组。
</code></pre>
<p>通过以下函数设置PGID：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">//该函数将PID为pid的进程的PGID设置为pgid</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setpgid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid)</span></span>;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<pre><code>1.一个进程只能设置自己或者其子进程的PGID
2.当子进程调用exec系列函数后，不能再在父进程中对它设置PGID
</code></pre>
<h4 id="7-3-2-会话"><a href="#7-3-2-会话" class="headerlink" title="7.3.2 会话"></a>7.3.2 会话</h4><pre><code>一些有关联的进程组将形成一个会话（session）
</code></pre>
<p>创建会话：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">setsid</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<pre><code>该函数不能由进程组的首领进程调用。
</code></pre>
<p>获取会话ID：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">getsid</span><span class="params">(<span class="type">pid_t</span> pid)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="7-3-3-用ps命令查看进程关系"><a href="#7-3-3-用ps命令查看进程关系" class="headerlink" title="7.3.3 用ps命令查看进程关系"></a>7.3.3 用ps命令查看进程关系</h4><h3 id="7-4-系统资源限制"><a href="#7-4-系统资源限制" class="headerlink" title="7.4 系统资源限制"></a>7.4 系统资源限制</h3><p>Linux系统资源限制通过如下一对函数进行读取和设置：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getrlimit</span><span class="params">(<span class="type">int</span> resource, <span class="keyword">struct</span> rlimit* rlim)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setrlimit</span><span class="params">(<span class="type">int</span> resource, <span class="type">const</span> <span class="keyword">struct</span> rlimit* rlim)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">rlimit</span> &#123;</span><br><span class="line">    <span class="type">rlim_t</span> rlim_cur;</span><br><span class="line">    <span class="type">rlim_t</span> rlim_max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="7-5-改变工作目录和根目录"><a href="#7-5-改变工作目录和根目录" class="headerlink" title="7.5 改变工作目录和根目录"></a>7.5 改变工作目录和根目录</h3><p>获取进程当前工作目录、改变进程工作目录：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">getcwd</span><span class="params">(<span class="type">char</span>* buf, <span class="type">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cndir</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path)</span></span>;</span><br></pre></td></tr></table></figure>
<p>改变进程根目录：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">chroot</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="7-6-服务器程序后台化"><a href="#7-6-服务器程序后台化" class="headerlink" title="7.6 服务器程序后台化"></a>7.6 服务器程序后台化</h3><pre><code>讨论如何在代码中，让一个进程以守护进程的方式运行。
</code></pre>
<p>Linux提供的库函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">daemon</span> <span class="params">(<span class="type">int</span> nochdir, <span class="type">int</span> noclose)</span></span>;</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<pre><code>nochdir：用于指定是否改变工作目录，如果传递0，则工作目录将被设置为“/”根目录，否则继续使用当前工作目录。
noclose：为0时，标准输入、标准输出和标准错误输出都被重定向到/dev/null文件，否则依然使用原来的设备。
</code></pre>
<hr>
<h2 id="第8章-高性能服务器程序框架"><a href="#第8章-高性能服务器程序框架" class="headerlink" title="第8章 高性能服务器程序框架"></a>第8章 高性能服务器程序框架</h2><p>将服务器解构为如下三个主要模块：</p>
<pre><code>1.I/O处理单元。
2.逻辑单元。
3.存储单元。
</code></pre>
<h3 id="8-1-服务器模型"><a href="#8-1-服务器模型" class="headerlink" title="8.1 服务器模型"></a>8.1 服务器模型</h3><h4 id="8-1-1-C-S模型"><a href="#8-1-1-C-S模型" class="headerlink" title="8.1.1 C&#x2F;S模型"></a>8.1.1 C&#x2F;S模型</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/12/21/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/" data-id="clqkoob8w000118v83h4t0avo" data-title="Linux高性能服务器编程学习笔记（二）" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Linux高性能服务器编程(一)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/12/12/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B(%E4%B8%80)/" class="article-date">
  <time class="dt-published" datetime="2023-12-12T12:24:11.000Z" itemprop="datePublished">2023-12-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/12/12/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B(%E4%B8%80)/">Linus高性能服务器编程学习笔记（一）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="第一部分-TCP-IP协议详解（1-4章）"><a href="#第一部分-TCP-IP协议详解（1-4章）" class="headerlink" title="第一部分 TCP&#x2F;IP协议详解（1~4章）"></a>第一部分 TCP&#x2F;IP协议详解（1~4章）</h1><h2 id="第一章-TCP-IP协议族"><a href="#第一章-TCP-IP协议族" class="headerlink" title="第一章 TCP&#x2F;IP协议族"></a>第一章 TCP&#x2F;IP协议族</h2><h3 id="1-1-TCP-IP协议族体系结构以及主要协议"><a href="#1-1-TCP-IP协议族体系结构以及主要协议" class="headerlink" title="1.1 TCP&#x2F;IP协议族体系结构以及主要协议"></a>1.1 TCP&#x2F;IP协议族体系结构以及主要协议</h3><p>TCP&#x2F;IP协议族是一个四层协议系统：自底而上分别是数据链路层、网络层、传输层、应用层</p>

<p><img src="/2023/12/12/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B(%E4%B8%80)/image.png" alt="TCP/IP四层协议系统"></p>
<h4 id="1-1-1-数据链路层"><a href="#1-1-1-数据链路层" class="headerlink" title="1.1.1 数据链路层"></a>1.1.1 数据链路层</h4><p>1.常用的协议：ARP协议（地址解析协议）、RARP协议（逆地址解析协议）</p>
<p>2.作用：实现了IP地址和物理MAC地址之间的转换。</p>
<h4 id="1-1-2-网络层"><a href="#1-1-2-网络层" class="headerlink" title="1.1.2 网络层"></a>1.1.2 网络层</h4><p>1.常用协议：IP协议、ICMP协议</p>
<p>2.作用：实现数据包的选路和转发。</p>
<p>3.方式：IP协议根据数据包的IP地址，使用逐跳（hop by hop）的方式确定通信路径。</p>
<p>4.注意：ICMP协议并非严格意义上的网络层，因为它使用的是处于同一层的IP协议提供的服务。（一般上层协议使用下层协议提供的服务）</p>
<h4 id="1-1-3-传输层"><a href="#1-1-3-传输层" class="headerlink" title="1.1.3 传输层"></a>1.1.3 传输层</h4><p>1.常用协议：TCP协议、UDP协议、SCTP协议</p>
<p>2.作用：为两台主机上的应用程序提供端到端的通信。</p>
<p>3.方式：</p>
<pre><code>（1）TCP：为应用层提供可靠的、面向连接的、基于流的服务。

        前提：使用双方必须先建立TCP连接

（2）UDP：为应用层提供不可靠的、无连接的、基于数据报的服务。

（3）SCTP：本书不讨论。
</code></pre>
<h4 id="1-1-4-应用层"><a href="#1-1-4-应用层" class="headerlink" title="1.1.4 应用层"></a>1.1.4 应用层</h4><p>1.常用协议：DNS协议、telnet协议、ping（工具）</p>
<p>2.作用：处理应用程序的逻辑</p>
<h3 id="1-2-封装"><a href="#1-2-封装" class="headerlink" title="1.2 封装"></a>1.2 封装</h3><pre><code>上层协议到底是如何使用下层协议提供的服务的呢？——————通过封装实现

（应用层）应用数据——&gt;（传输层）TCP\UDP封装成TCO段\UDP数据报——&gt;（网络层）IP封装成IP数据报——&gt;（数据链路层）封装成帧

至此封装结束，帧才是最终在物理网络上传送的字节序列！
</code></pre>

<p><img src="/2023/12/12/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B(%E4%B8%80)/image-1.png" alt="封装"></p>
<h3 id="1-3-分用"><a href="#1-3-分用" class="headerlink" title="1.3 分用"></a>1.3 分用</h3><pre><code>分用：帧到达目的主机后，依次自底向上处理各自层的数据，并将最后处理好的帧交给目标应用程序。
</code></pre>

<p><img src="/2023/12/12/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B(%E4%B8%80)/image-2.png" alt="分用"></p>
<pre><code>原应用程序——&gt;原始数据——&gt;封装——&gt;分用——&gt;目标应用程序

在顶层目标服务看来，封装和分用似乎没有发生过。
</code></pre>
<h3 id="1-4-测试网络（略）"><a href="#1-4-测试网络（略）" class="headerlink" title="1.4 测试网络（略）"></a>1.4 测试网络（略）</h3><h3 id="1-5-ARP工作原理"><a href="#1-5-ARP工作原理" class="headerlink" title="1.5 ARP工作原理"></a>1.5 ARP工作原理</h3><pre><code>本书仅讨论从IP地址——&gt;以太网（MAC）地址的转换。


原理：主机向自己所在网络广播一个ARP请求，该请求包含目标机器的网络地址。网络上的所有机器都将收到这个请求，但只有目的主机会回应一个应答，该应答包含目的主机自己的物理MAC地址。
</code></pre>
<div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"theme":"#FADFA3","loop":true,"video":{"url":"/2023/12/12/Linux高性能服务器编程(一)/ARP请求.mp4","pic":"1.png"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>

<div id="dplayer1" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer1"),"theme":"#FADFA3","loop":true,"video":{"url":"/2023/12/12/Linux高性能服务器编程(一)/ARP应答.mp4","pic":"1.png"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>

<h4 id="1-5-1-ARP高速缓存"><a href="#1-5-1-ARP高速缓存" class="headerlink" title="1.5.1 ARP高速缓存"></a>1.5.1 ARP高速缓存</h4><pre><code>ARP高速缓存：包含经常访问或最近访问的机器的 IP地址到MAC地址的映射。

作用：避免了重复的ARP请求，提高了发送数据包的速度。
</code></pre>
<h3 id="1-6-DNS工作原理"><a href="#1-6-DNS工作原理" class="headerlink" title="1.6 DNS工作原理"></a>1.6 DNS工作原理</h3><pre><code>作用：通常我们使用机器的域名来访问机器，而不是直接使用其IP地址，比如访问因特网的网站。那么将机器的域名转换为IP地址，就需要用到 域名查询服务。

DNS：一种域名查询服务，将机器的域名转换为IP地址。
</code></pre>
<h4 id="1-6-1-DNS查询和应答报文详解"><a href="#1-6-1-DNS查询和应答报文详解" class="headerlink" title="1.6.1 DNS查询和应答报文详解"></a>1.6.1 DNS查询和应答报文详解</h4><pre><code>DNS：一套分布式的域名服务系统。每个DNS服务器存放这大量的 机器名和IP地址映射,并且是动态更新的。
</code></pre>
<h3 id="1-7-socket和TCP-IP协议族的关系"><a href="#1-7-socket和TCP-IP协议族的关系" class="headerlink" title="1.7 socket和TCP&#x2F;IP协议族的关系"></a>1.7 socket和TCP&#x2F;IP协议族的关系</h3><pre><code>前文提到，下三层（数据链路层、网络层、传输层）协议是在内核中实现的，因此操作系统需要实现一组系统调用，让应用程序能够访问这些协议提供的服务。实现这组系统调用的API主要有两套：soket和XTI，XTI已基本不再使用。
</code></pre>
<p>socket定义的这组API提供如下两个功能：</p>
<pre><code>1.将应用程序数据从 用户缓冲区 中复制到TCP/UDP 内核发送缓冲区，以交付内核来发送数据；或者从 TCP/UDP接收缓冲区 复制数据到 用户缓冲区，以读取数据。

2.应用程序可以通过它们修改内核中各层协议的某些头部信息或者数据结构，从而控制底层通信行为。（比如通过setsockopt函数设置IP数据报在网络中的存活时间）。
</code></pre>
<hr>
<h2 id="第二章-IP协议详解"><a href="#第二章-IP协议详解" class="headerlink" title="第二章 IP协议详解"></a>第二章 IP协议详解</h2><pre><code>IP协议是TCP/IP协议的核心协议，也是socket网络编程的基础之一。主要从两方面深入探讨IP协议：

    1.IP头部信息：IP头部信息出现在每个IP数据报中，用于指定IP通信的源端IP地址、目的IP地址，指导IP分片和重组，以及指定部分通信行为。

    2.IP数据报的路由和转发：IP数据报的路由和转发发生在 除目标主机之外 的所有主机和路由器上。它们决定数据报是否应该转发及如何转发。 
</code></pre>
<h3 id="2-1-IP服务的特点"><a href="#2-1-IP服务的特点" class="headerlink" title="2.1 IP服务的特点"></a>2.1 IP服务的特点</h3><pre><code>IP协议是TCP/IP协议族的动力，为上层提供无状态、无连接、不可靠的服务。
    1.无状态：IP通信双方不同步传输数据的状态信息，因此所有IP数据报的发送、传输、接收都是相互独立、没有上下文关系的。
        （1）缺点：无法处理乱序的、重复的IP数据报
        （2）优点：简单、高效
    
    2.无连接：IP通信双方都不长久的维持对方的任何信息。因此，上层协议每次发送数据报的时候，都必须明确指定对方的IP地址。
    
    3.不可靠：IP协议不能保证IP数据报准确的到达接收端，只是承诺“尽最大努力”。
        发送端一旦检测到IP数据报发送失败，就通知上层协议发送失败，而且不会重传。因此，使用IP服务的上层协议（如TCP协议）需要自己实现数据确认、超时重传等机制以达到可靠传输的目的。
</code></pre>
<h3 id="2-2-IPv4头部结构"><a href="#2-2-IPv4头部结构" class="headerlink" title="2.2 IPv4头部结构"></a>2.2 IPv4头部结构</h3><h4 id="2-2-1-IPv4头部结构"><a href="#2-2-1-IPv4头部结构" class="headerlink" title="2.2.1 IPv4头部结构"></a>2.2.1 IPv4头部结构</h4><pre><code>IPv4头部结构通常为 20字节 + 40字节（选项部分）= 最长60字节   //1字节=8比特/位
</code></pre>

<p><img src="/2023/12/12/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B(%E4%B8%80)/image-3.png" alt="IPv4头部结构"></p>
<p>第一行：</p>
<pre><code>4位版本号：指定IP协议的版本，其值是4。

4位头部长度：标志该IP头部有多少个4字节。因为4为最多能表示15，所以IP头部最长为60字节。

8位服务类型：
    3位优先权字段（现已忽略）
    4位服务类型字段（最小延迟、最大吞吐量、最高可靠性、最小费用，只能有一个置1，应用程序根据实际需要设置）
    1位保留字段（必须置0）

16位总长度：标识该IP数据报的总长度，以字节为单位。由于MTU（最大传输单元）限制，长度超过MTU的数据报将被分片传输，所以实际传输的IP数据报都远远没有达到最大长度。
</code></pre>
<p>第二行：（实现分片）</p>
<pre><code>16位标识：每个IP数据报的唯一标识，初始值由系统随机生成：每发送一个数据报，其值就加1。同一个数据报的所有分片都具有相同的标识值。

3位标志：
    第一位保留。
    第二位：DF（Don&#39;t Fragment）表示“禁止分片”。如果设置了DF位，且IP数据报长度超过了MTU，那么IP模块会丢弃该数据报并返回一个ICMP差错报文。
    第三位：MF（More Fragment）表示“更多分片”。除了数据报的最后一个分片外，其他分片都要设置为1

13位分片偏移：分片相对于原始数据报开始处的偏移。除了最后一个分片外，其他分片的数据部分长度必须是8的整倍数
</code></pre>
<p>第三行：</p>
<pre><code>8位生存时间：TTL（Time To Live）是数据报到达目的地前允许经过路由的跳数。每经过一个路由，TTL值被路由器-1。
    TTL减为0时，路由器将丢弃数据报，并向源端发送一个ICMP差错报文。
    TTL值可以防止数据报陷入路由循环。

8位协议：用来区分上层协议：
    ICMP是1，注意ICMP是和IP同层的！
    TCP是6
    UDP是17

16位头部校验：由发送端填充，接收端使用CRC算法以校验IP数据报头部（注意，仅校验头部）在传输过程中是否损坏。
</code></pre>
<p>第四行、第五行：</p>
<pre><code>32位源端IP地址 + 32位目的端IP地址
</code></pre>
<p>第六行：</p>
<pre><code>可变长的可选信息字段：这部分最多包含40个字节。
    可用选项：记录路由、时间戳、松散源路由选择(必须经过所指路由器)、严格源路由选择（只能经过所指路由器）
</code></pre>
<h3 id="2-3-IP分片"><a href="#2-3-IP分片" class="headerlink" title="2.3 IP分片"></a>2.3 IP分片</h3><pre><code>1.当IP数据报长度超过MTU时候，将被分片传输。

2.分片可能发生在发送端、中转路由器上，也可能在传输过程中被多次分片，但只有在最终的目标机器上，这些分片才会被IP模块重组。

3.同一个IP数据报的每个分片都有自己的IP头部，它们具有相同的标识值，但具有不同的片偏移。

4.除了最后一个分片外，其余分片都将设置MF标志。

5.以太网帧的MTU是1500字节（1480字节数据部分 + 20字节IP头部）
</code></pre>

<p><img src="/2023/12/12/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B(%E4%B8%80)/image.png" alt="分片"></p>
<h3 id="2-4-IP路由"><a href="#2-4-IP路由" class="headerlink" title="2.4 IP路由"></a>2.4 IP路由</h3><pre><code>IP协议的一个核心任务就是数据报的路由————决定数据报到目标机器的路径。
</code></pre>
<h4 id="2-4-1-IP模块工作流程"><a href="#2-4-1-IP模块工作流程" class="headerlink" title="2.4.1 IP模块工作流程"></a>2.4.1 IP模块工作流程</h4>
<p><img src="/2023/12/12/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B(%E4%B8%80)/image-4.png" alt="IP模块工作流程"></p>
<h3 id="2-5-IP转发"><a href="#2-5-IP转发" class="headerlink" title="2.5 IP转发"></a>2.5 IP转发</h3><pre><code>不是转发给本机的IP数据报，将交由数据报转发子模块处理。

路由器都能执行数据报的转发功能，而主机一般只发送和接受数据。
</code></pre>
<h3 id="2-6-重定向"><a href="#2-6-重定向" class="headerlink" title="2.6 重定向"></a>2.6 重定向</h3><pre><code>ICMP重定向报文也能更新路由表。
</code></pre>
<h4 id="2-6-1-ICMP重定向报文"><a href="#2-6-1-ICMP重定向报文" class="headerlink" title="2.6.1 ICMP重定向报文"></a>2.6.1 ICMP重定向报文</h4>
<p><img src="/2023/12/12/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B(%E4%B8%80)/image-5.png" alt="ICMP重定向报文"></p>
<pre><code>一般来说，主机只能接受ICMP重定向报文，路由器只能发送ICMP重定向报文。
</code></pre>
<h3 id="2-7-IPv6头部结构"><a href="#2-7-IPv6头部结构" class="headerlink" title="2.7 IPv6头部结构"></a>2.7 IPv6头部结构</h3><pre><code>40字节固定头部 + 扩展头部
</code></pre>

<p><img src="/2023/12/12/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B(%E4%B8%80)/image-6.png" alt="IPv6头部结构"></p>
<hr>
<h2 id="第三章-TCP协议详解"><a href="#第三章-TCP协议详解" class="headerlink" title="第三章 TCP协议详解"></a>第三章 TCP协议详解</h2><pre><code>和IP协议相比，TCP协议更靠近应用层，因此在应用程序中具有更强的可操作性。

主要从以下四个方面来讨论TCP协议：

    1.TCP头部信息：出现在每个TCP报文段中
        作用：指定通信的源端端口号、目的端端口号，管理TCP连接，控制两个方向的数据流

    2.TCP状态转移过程：TCP连接的任意一端都是一个状态机，TCP连接从建立到断开的整个过程中，两端的状态机都将经历不同的状态变迁。

    3.TCP数据流：
        （1）交互数据流
        （2）成块数据流
    TCP数据流中有一种特殊的数据：紧急数据

    4.TCP数据流的控制：为了保证可靠传输和提高网络通信质量，内核需要对TCP数据流进行控制。
        （1）超时重传
        （2）拥塞控制
</code></pre>
<h3 id="3-1-TCP服务的特点"><a href="#3-1-TCP服务的特点" class="headerlink" title="3.1 TCP服务的特点"></a>3.1 TCP服务的特点</h3><pre><code>传输层主要有两个协议：TCP协议   UDP协议

TCP协议相对于UDP协议的特点是：面向连接、字节流和可靠传输

1.使用TCP协议通信前提：

    （1）双方必须先建立TCP连接，才能开始数据的读写。

    （2）双方必须为连接分配必要的内核资源————管理连接状态、连接上的数据的传输。

2.TCP连接是全双工的————双方的数据读写可以通过一条连接进行。

3.完成通信后，双方必须都断开连接，以释放系统资源！

注意：

    TCP连接是一对一的，因此基于广播和多播的应用程序不能使用TCP服务，可以选择使用无连接协议UDP。
</code></pre>
<h4 id="3-1-1-TCP协议面向字节流概念：应用程序对数据的发送和接受是没有边界限制的！"><a href="#3-1-1-TCP协议面向字节流概念：应用程序对数据的发送和接受是没有边界限制的！" class="headerlink" title="3.1.1 TCP协议面向字节流概念：应用程序对数据的发送和接受是没有边界限制的！"></a>3.1.1 TCP协议面向字节流概念：应用程序对数据的发送和接受是没有边界限制的！</h4><pre><code>发送端执行的写操作次数和接收端执行的读操作次数没有任何数量观念。

（1）发送端原理：发送端连续执行多次写操作——&gt;TCP模块将这些数据放入到发送缓冲区——&gt;TCP模块真正开始发送数据时，将发送缓冲区的待发送数据封装成一个或多个TCP报文段发出

（2）接收端原理：接收端收到一个或多个TCP报文段——&gt;按照TCP报文段序号放入到TCP接收缓冲区，并通知应用程序读取数据——&gt;应用程序根据接受缓冲区的大小，可以一次性全部读出数据，也可以分多次读取。
</code></pre>
<h4 id="3-1-2-UDP协议面向数据报概念："><a href="#3-1-2-UDP协议面向数据报概念：" class="headerlink" title="3.1.2 UDP协议面向数据报概念："></a>3.1.2 UDP协议面向数据报概念：</h4><pre><code>发送端每写一个操作，UDP模块就将其封装成一个UDP数据报并发送之。

接收端必须及时针对每一个数据报进行读操作，否则会丢包！

并且，如果用户没有指定足够的应用程序缓冲区来读取UDP数据，则UDP数据将被截断！
</code></pre>

<p><img src="/2023/12/12/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B(%E4%B8%80)/image-7.png" alt="TCP和UDP服务"></p>
<p>TCP传输是可靠的：</p>
<pre><code>（1）发送应答机制。发送端每发送一个TCP报文都必须得到接收端的应答，才认为传输成功。

（2）超时重传机制。发送端发送一个TCP报文启动定时器，若定时器时间内未收到应答，将重新发送该报文。

（3）由于IP数据报可能会乱序、重复，所以TCP协议会对接受到的TCP报文重排、整理，在交付给应用层。

注意：UDP协议和IP协议一样，都是提供不可靠服务，需要上层协议处理数据确认和超时重传等。
</code></pre>
<h3 id="3-2-TCP头部结构"><a href="#3-2-TCP头部结构" class="headerlink" title="3.2 TCP头部结构"></a>3.2 TCP头部结构</h3><pre><code>TCP头部结构：出现在每个TCP报文段中。
    固定头部 + 头部选项
    作用：指定通信源端端口、目的端端口、管理TCP连接等。
</code></pre>
<h4 id="3-2-1-TCP固定头部结构"><a href="#3-2-1-TCP固定头部结构" class="headerlink" title="3.2.1 TCP固定头部结构"></a>3.2.1 TCP固定头部结构</h4>
<p><img src="/2023/12/12/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B(%E4%B8%80)/image-8.png" alt="TCP头部结构"></p>
<pre><code>1.16位源端口号、16位目的端口号：
    告知主机该报文段来自哪里（源端口），以及要传输给哪个上层协议或者应用程序（目的端口）。

2.32位序号：
    一次TCP通信中的。某一个方向上的字节流的每个字节的编号。

3.32位确认号：
    对另一方发来的TCP报文段的响应。

4.4位头部长度：用来标识TCP头部有多少个4字节。  TCP头部最长是60字节。

5.6位标识为：
    （1）URG：紧急指针是否有效
    （2）ACK：确认号是否有效
    （3）PSH：提示接收端立刻从接收缓冲区读数据，腾空间！
    （4）RST：要求对方重新建立连接（复位报文段）
    （5）SYN：请求建立一个连接（同步报文段）
    （6）FIN：通知对方，本端要关闭连接了（结束报文段）
6.16位窗口大小：是TCP流量控制的一个手段。告诉对方，本端的接受缓冲区还能容纳多少字节数据，这样对方可以控制发送数据的速度。

7.16位校验和：由发送端填充，接收端通过CRC算法校验TCP报文段在传输过程是否损坏。
    注意：不仅校验头部，也校验数据，这是TCP可靠传输的一个重要保障！

8.16位紧急指针：TCP发送端向接收端发送紧急数据的方法。
</code></pre>
<h4 id="3-2-2-TCP头部选项（40字节）"><a href="#3-2-2-TCP头部选项（40字节）" class="headerlink" title="3.2.2 TCP头部选项（40字节）"></a>3.2.2 TCP头部选项（40字节）</h4><pre><code>kind是选项类型、length是选项总长度、info是选项的具体信息
</code></pre>

<p><img src="/2023/12/12/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B(%E4%B8%80)/image-9.png" alt="TCP头部选项的一般结构"></p>
<pre><code>TCP选项：
</code></pre>

<p><img src="/2023/12/12/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B(%E4%B8%80)/image-10.png" alt="7种TCP选项"></p>
<pre><code>0：结束选项
1：空操作，无特殊意义，一般用来将TCP选项的总长度填充为4字节的倍数。
2：最大报文段长度
3：窗口扩大因子：只能出现在同步报文段中，且同步报文段本身不执行窗口扩大操作。
4：选择性确认：SACK技术——当出现报文段丢失时，TCP模块只重发丢失的TCP报文段。
5：SACK实际工作：告诉发送方，本端已接受并缓存了不连续的数据块，让发送端据此检查并重发丢失的数据块
8：时间戳：计算通信双方的回路时间，为TCP流量控制提供重要信息。
</code></pre>
<h3 id="3-3-TCP连接的建立与关闭"><a href="#3-3-TCP连接的建立与关闭" class="headerlink" title="3.3 TCP连接的建立与关闭"></a>3.3 TCP连接的建立与关闭</h3><h4 id="3-3-1-三次握手-四次挥手"><a href="#3-3-1-三次握手-四次挥手" class="headerlink" title="3.3.1 三次握手 + 四次挥手"></a>3.3.1 三次握手 + 四次挥手</h4>
<p><img src="/2023/12/12/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B(%E4%B8%80)/image-11.png" alt="TCP连接的建立和关闭"></p>
<pre><code>三次握手：TCP连接建立
    报文段1：客户端请求与服务器端建立连接
    报文段2：服务器端同意建立连接，并确认请求（将客户端发来的报文的ISN序号 + 1 代表确认）
    报文段3：客户端确认服务器端的同意（将服务器端发来的报文的ISN序号 + 1 代表确认）

四次挥手：TCP连接关闭
    报文段4：包含FIN标志，代表结束报文段，即客户端请求关闭连接
    报文段5：确认客户端的关闭连接请求（由于报文段6也有对关闭连接请求的确认，所以实际可忽略此报文段）
    报文段6：服务器端发送结束报文段，并确认客户端的关闭连接请求
    报文段7：确认服务器端的结束报文段

注意：由客户端先提出的关闭连接请求，因此客户端执行主动关闭，服务器端执行被动关闭
</code></pre>
<h4 id="3-3-2-半关闭状态"><a href="#3-3-2-半关闭状态" class="headerlink" title="3.3.2 半关闭状态"></a>3.3.2 半关闭状态</h4><pre><code>通信的一方可以给对方发送结束报文段，以告知对方本端发送完毕，但依旧允许接收对方发来的数据，直到对方也发来结束报文段以关闭连接为止。
</code></pre>
<h4 id="3-3-3-超时连接"><a href="#3-3-3-超时连接" class="headerlink" title="3.3.3 超时连接"></a>3.3.3 超时连接</h4><pre><code>原因：服务器相距很远或者服务器繁忙，导致服务器没有应答客户端发出的同步报文段。

客户端行为：客户端尝试重连，多次重连无效后（次数取决于内核变量的定义），告知应用程序连接超时。
</code></pre>
<h3 id="3-4-状态转移"><a href="#3-4-状态转移" class="headerlink" title="3.4 状态转移"></a>3.4 状态转移</h3><pre><code>TCP连接的任意一端在任一时刻都处于某种状态，使用netstat命令可以查看当前状态。
</code></pre>
<h4 id="3-4-1-TCP状态转移总图"><a href="#3-4-1-TCP状态转移总图" class="headerlink" title="3.4.1 TCP状态转移总图"></a>3.4.1 TCP状态转移总图</h4>
<p><img src="/2023/12/12/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B(%E4%B8%80)/image-12.png" alt="TCP状态转移总图"></p>
<h4 id="3-4-2-TIME-WAIT状态"><a href="#3-4-2-TIME-WAIT状态" class="headerlink" title="3.4.2 TIME_WAIT状态"></a>3.4.2 TIME_WAIT状态</h4><pre><code>客户端在收到服务器发来的结束报文段后，并不会立刻进入CLOSED状态，而是要等待2MSL（报文段最大生存时间）才进入CLOSED，其中MSL建议值为2min，那么就是等待4min后才进入CLOSED状态。
</code></pre>
<p>TIME_WAIT作用：</p>
<pre><code>1.可靠地终止TCP连接
2.保证迟来的报文段有足够时间被识别和丢弃
</code></pre>
<h3 id="3-5-复位报文段"><a href="#3-5-复位报文段" class="headerlink" title="3.5 复位报文段"></a>3.5 复位报文段</h3><p>产生复位报文段的三种情况：</p>
<pre><code>1.访问不存在端口（或者端口处于TIME_WAIT状态）
2.异常终止连接：通过给对方发送一个复位报文段，可以以异常终止一个连接
3.处理半打开连接：
    服务器端由于故障重启，导致之前建立的连接失效，但是客户端依旧处于之前的TCP连接，此时客户端就处于半打开状态，而它所处于的这个连接就成为半打开连接，如果客户端向该半打开连接写入数据，将会收到一个复位报文段。
</code></pre>
<h3 id="3-6-TCP交互数据流"><a href="#3-6-TCP交互数据流" class="headerlink" title="3.6 TCP交互数据流"></a>3.6 TCP交互数据流</h3><pre><code>TCP报文段所携带的应用程序数据：
    1.交互数据：

        特点：仅包含很少的字节，对实时性要求很高

    2.成块数据

        特点：通常为TCP报文段允许的最大数据长度，对传输效率要求高
</code></pre>
<h4 id="3-6-1-延迟确认"><a href="#3-6-1-延迟确认" class="headerlink" title="3.6.1 延迟确认"></a>3.6.1 延迟确认</h4><pre><code>服务器不马上确认上次收到的数据，而是在一段延迟后查看本端是否有数据要发送，如果有，会将数据和对上次的确认一并发出。

    作用：可以减少TCP报文的发送数量。
</code></pre>
<h3 id="3-7-成块数据流"><a href="#3-7-成块数据流" class="headerlink" title="3.7 成块数据流"></a>3.7 成块数据流</h3><pre><code>一般是传输大文件。
</code></pre>
<h3 id="3-8-带外数据"><a href="#3-8-带外数据" class="headerlink" title="3.8 带外数据"></a>3.8 带外数据</h3><pre><code>带外（OOB，Out Of Band）数据：用于迅速告知对方本端发生的重要事件，具有更高的优先级！
</code></pre>
<p>UDP：</p>
<pre><code>没有实现带外数据传输。
</code></pre>
<p>TCP:</p>
<pre><code>TCP利用头部的紧急指针标志和紧急指针，给应用程序提供了一种紧急方式，利用传输普通数据的连接传输紧急数据。这种紧急数据和带外数据类似，因此也将TCP紧急数据称为带外数据。
</code></pre>
<h3 id="3-9-TCP超时重传"><a href="#3-9-TCP超时重传" class="headerlink" title="3.9 TCP超时重传"></a>3.9 TCP超时重传</h3><pre><code>TCP模块为每一个TCP报文段都维护一个重传定时器，该定时器在TCP报文段第一次被发送时启动。
如果在定时器规定时间内没有收到对方的应答，将重传该报文段并重置定时器（时间由TCP重传策略决定，一般下一次时间将翻倍）
</code></pre>
<p>注意：</p>
<pre><code>虽然超时会导致TCP报文段重传，但是重传也可以发生在超时之前，即快速重传。
</code></pre>
<h3 id="3-10-拥塞控制"><a href="#3-10-拥塞控制" class="headerlink" title="3.10 拥塞控制"></a>3.10 拥塞控制</h3><pre><code>拥塞控制：提高网络利用率，降低丢包率，保证网络资源对每条数据流的公平性。

包含四部分：慢启动、拥塞避免、快速重传、快速恢复
</code></pre>
<p>专业名词：</p>
<pre><code>发送窗口（SWND）：限制发送端能连续发送TCP报文段的数量。

接收窗口（RWND）：接收通告窗口，可以控制发送端的SWND，但显然不够，所以发送端引入了拥塞窗口。

拥塞窗口（CWND）：发送窗口 = Min（拥塞窗口，接收窗口）
</code></pre>

<p><img src="/2023/12/12/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B(%E4%B8%80)/image-13.png" alt="拥塞控制的输入和输出"></p>
<h4 id="3-10-1-慢启动和拥塞避免"><a href="#3-10-1-慢启动和拥塞避免" class="headerlink" title="3.10.1 慢启动和拥塞避免"></a>3.10.1 慢启动和拥塞避免</h4>
<p><img src="/2023/12/12/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B(%E4%B8%80)/image-15.png" alt="慢启动和拥塞避免"></p>
<p>慢启动：</p>
<pre><code>TCP模块刚开始并不知道网络的实际情况，所以需要一种试探的方式，来平滑的增大（以指数形式增大）CWND的大小。
但是CWND不能无止境的增大，因此有一个慢启动门限，当CWND大小超过慢启动门限，则进入拥塞避免阶段。
</code></pre>
<p>拥塞避免：</p>
<pre><code>使CWND按照线性方式增加，减缓其扩大。
</code></pre>
<p>发送端判断拥塞发生时的依据：</p>
<pre><code>1.传输超时（重传定时器溢出）

2.接收到重复的确认报文段
</code></pre>
<h4 id="3-10-2-快速重传和快速恢复"><a href="#3-10-2-快速重传和快速恢复" class="headerlink" title="3.10.2 快速重传和快速恢复"></a>3.10.2 快速重传和快速恢复</h4><p>注意：</p>
<pre><code>很多情况下都会导致发送端收到重复的确认报文段，而不一定是由网络拥塞导致的，因此，如果发送端连续收到3个重复的确认报文段，则判定为网络拥塞，然后启用快速重传和快速恢复算法处理拥塞。
</code></pre>
<p>快速重传：</p>
<pre><code>发送方连续收到三个重复的确认应答后，进行相应确实报文段的重传。
</code></pre>

<p><img src="/2023/12/12/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B(%E4%B8%80)/image-16.png" alt="快速重传"></p>
<p>快速恢复：</p>
<pre><code>将慢开始门限更新为连续收到3次重复确认时的拥塞窗口的一半，然后更新拥塞窗口到该新的慢开始门限，直接执行拥塞避免算法。
</code></pre>

<p><img src="/2023/12/12/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B(%E4%B8%80)/image-17.png" alt="快速恢复"></p>
<hr>
<h2 id="第四章-TCP-IP通信案例：访问internet上的服务器"><a href="#第四章-TCP-IP通信案例：访问internet上的服务器" class="headerlink" title="第四章 TCP&#x2F;IP通信案例：访问internet上的服务器"></a>第四章 TCP&#x2F;IP通信案例：访问internet上的服务器</h2><h3 id="4-1-实例总图"><a href="#4-1-实例总图" class="headerlink" title="4.1 实例总图"></a>4.1 实例总图</h3>
<p><img src="/2023/12/12/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B(%E4%B8%80)/image-18.png" alt="实例总图"></p>
<pre><code>HTTP协议：应用层的一种协议，默认使用的传输层协议是TCP
</code></pre>
<h3 id="4-2-部署代理服务器"><a href="#4-2-部署代理服务器" class="headerlink" title="4.2 部署代理服务器"></a>4.2 部署代理服务器</h3><h4 id="4-2-1-HTTP代理服务器的工作原理"><a href="#4-2-1-HTTP代理服务器的工作原理" class="headerlink" title="4.2.1 HTTP代理服务器的工作原理"></a>4.2.1 HTTP代理服务器的工作原理</h4><p>说明：</p>
<pre><code>1.在HTTP通信链上，客户端和目标服务器之间通常存在某些中转代理服务器，它们提供对目标的中转访问。

2.一个HTTP请求可能被多个代理服务器转发，后面服务器称为上游服务器。
</code></pre>
<p>代理服务器：</p>
<pre><code>1.正向代理服务器：要求客户端自己设置代理服务器的地址，每次HTTP请求都直接由该代理服务器负责

2.反向代理服务器：设置在服务端，用代理服务器接收Internet上的请求，然后转发给内部网络上的服务器。

3.透明代理服务器：只能设置在网关上，可以看作是正向代理的一种特殊情况
</code></pre>

<p><img src="/2023/12/12/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B(%E4%B8%80)/image-19.png" alt="代理服务器"></p>
<p>注意：</p>
<pre><code>IP头部的源端地址和目的端地址是始终不变的，而帧头部的源端物理地址和目的端物理地址则是一直变化的
</code></pre>
<h3 id="4-4-访问DNS服务器"><a href="#4-4-访问DNS服务器" class="headerlink" title="4.4 访问DNS服务器"></a>4.4 访问DNS服务器</h3><pre><code>解析主机名的顺序：先访问本地 /etc/hosts，再访问DNS服务
</code></pre>
<h3 id="4-6-HTTP通信"><a href="#4-6-HTTP通信" class="headerlink" title="4.6 HTTP通信"></a>4.6 HTTP通信</h3>
<p><img src="/2023/12/12/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B(%E4%B8%80)/image-20.png" alt="HTTP通信"></p>
<h4 id="4-6-1-HTTP请求"><a href="#4-6-1-HTTP请求" class="headerlink" title="4.6.1 HTTP请求"></a>4.6.1 HTTP请求</h4><pre><code>短链接：同一客户的多个连续HTTP请求不能共用同一个TCP连接

长连接：多个请求可以使用同一个TCP连接，
</code></pre>
<p>长连接的好处：</p>
<pre><code>极大减少了网络上建立TCP连接造成的符合，同时缩减了每个请求的处理时间。
</code></pre>
<h4 id="4-6-2-HTTP应答"><a href="#4-6-2-HTTP应答" class="headerlink" title="4.6.2 HTTP应答"></a>4.6.2 HTTP应答</h4><pre><code>注意：HTTP协议是一种无状态协议，每个HTTP请求之间不存在任何上下文关系。

如果服务器处理后续HTTP请求时需要用到前面的，那么客户端就必须重发一次前面的。
</code></pre>
<p>Cookie</p>
<pre><code>保持HTTP连接状态的措施。
</code></pre>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/12/12/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B(%E4%B8%80)/" data-id="clqkoob8s000018v8bvfo3dlp" data-title="Linus高性能服务器编程学习笔记（一）" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>



  

</section>
        <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/12/21/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/">Linux高性能服务器编程学习笔记（二）</a>
          </li>
        
          <li>
            <a href="/2023/12/12/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B(%E4%B8%80)/">Linus高性能服务器编程学习笔记（一）</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/12/">十二月 2023</a></li></ul>
    </div>
  </div>

  
</aside>
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 By Autoload<br>
      Driven - <a href="https://hexo.io/" target="_blank">Hexo</a>|Theme - <a href="https://github.com/autoload/hexo-theme-auto" target="_blank">Auto</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>


<script src="/js/script.js"></script>




  </div>
</body>
</html>